<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŽ“ Canvas Learning Assistant</title>
    <!-- PDF.js for PDF text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Mammoth.js for Word document extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- JSZip for PowerPoint and ZIP extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --accent-color-1: #667eea;
            --accent-color-2: #764ba2;
            --note-font-size: 16px;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        html {
            background: #000;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Welcome Screen */
        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            transition: opacity 1s ease-out;
            opacity: 1;
        }
        
        .welcome-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .welcome-message {
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
            animation: welcomeSlideIn 1.2s cubic-bezier(0.4, 0, 0.2, 1), welcomePulse 2s ease-in-out 1.5s infinite;
            text-align: center;
            white-space: nowrap;
        }
        
        @keyframes welcomeSlideIn {
            0% {
                opacity: 0;
                transform: translateX(-150px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes welcomePulse {
            0%, 100% {
                transform: translateX(0) scale(1);
            }
            50% {
                transform: translateX(0) scale(1.05);
            }
        }
        
        .logo {
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 3rem;
            letter-spacing: -0.02em;
        }
        
        .token-input {
            width: 520px;
            padding: 1.5rem 2rem;
            font-size: 1.1rem;
            border: 1.5px solid rgba(255, 255, 255, 0.18);
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.07);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            color: #fff;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .token-input:focus {
            outline: none;
            border-color: var(--accent-color-1);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.25);
            transform: translateY(-2px);
        }
        
        .token-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .instruction-text {
            color: rgba(255, 255, 255, 0.6);
            margin: 1.5rem 0 1rem;
            text-align: center;
            font-size: 1rem;
            font-weight: 400;
        }
        
        .instructions-toggle {
            color: rgba(108, 160, 255, 0.8);
            margin: 0.5rem 0 2rem;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            text-decoration: underline;
            transition: color 0.3s ease;
        }
        
        .instructions-toggle:hover {
            color: rgba(108, 160, 255, 1);
        }
        
        .instructions-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            display: none;
            text-align: left;
            animation: fadeIn 0.3s ease-out;
            z-index: 10001;
            overflow-y: scroll;
            overflow-x: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch;
        }
        
        .instructions-panel.active {
            display: block;
        }
        
        /* Instructions overlay background - transparent and non-interactive */
        .instructions-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
            pointer-events: none;
        }
        
        .instructions-overlay.active {
            display: block;
            pointer-events: none; /* Keep it non-interactive so clicks pass through */
        }
        
        /* Close button for instructions */
        .instructions-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .instructions-close:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }
        
        .instructions-panel h3 {
            color: #fff;
            font-size: 1.2rem;
            margin: 0 2.5rem 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .instructions-panel h4 {
            color: rgba(108, 160, 255, 0.9);
            font-size: 1rem;
            margin: 1.5rem 0 0.5rem 0;
        }
        
        .instructions-panel ol, .instructions-panel ul {
            color: rgba(255, 255, 255, 0.8);
            margin: 0.5rem 0 1rem 1.5rem;
            line-height: 1.6;
        }
        
        .instructions-panel li {
            margin: 0.5rem 0;
        }
        
        .instructions-panel code {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: rgba(108, 160, 255, 0.9);
        }
        
        .instructions-panel a {
            color: rgba(108, 160, 255, 0.9);
            text-decoration: underline;
        }
        
        .instructions-panel a:hover {
            color: rgba(108, 160, 255, 1);
        }
        
        .load-btn {
            padding: 1.2rem 3.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        
        .load-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(102, 126, 234, 0.5);
        }
        
        .load-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Button Styles */
        .btn {
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: inline-block;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            color: #fff;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.6);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }
        
        /* Main Dashboard */
        .dashboard {
            display: none;
            min-height: 100vh;
            overflow: visible; /* Allow tooltips to show */
        }
        
        .dashboard.active {
            display: block;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2rem 3rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            background: rgba(0, 0, 0, 0.5);
            overflow: visible; /* Allow tooltips to show */
        }
        
        .header h1 {
            font-size: 2.2rem;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        
        .header-buttons {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            overflow: visible; /* Allow tooltips to show */
        }
        
        .header-btn {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            color: #fff;
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none; /* Hidden by default, shown when notes are loaded */
            align-items: center;
            justify-content: center;
            padding: 0;
            position: relative;
        }
        
        .header-btn:hover {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 12px rgba(108, 160, 255, 0.3);
            filter: brightness(1.2);
        }
        
        .header-btn:hover:not(:active) {
            transform: translateY(-2px);
        }
        
        .header-btn:active {
            transform: translateY(0);
            filter: brightness(0.9);
        }
        
        /* Tooltip container for header buttons */
        .header-btn .tooltip,
        .settings-btn .tooltip {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease 0.1s, transform 0.2s ease 0.1s;
            z-index: 999999;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            visibility: hidden;
            line-height: 1.4;
        }
        
        .header-btn:hover .tooltip,
        .settings-btn:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-2px);
        }
        
        /* Ensure tooltips are visible even when parent is clipped */
        .header-btn,
        .settings-btn {
            overflow: visible !important;
        }
        
        .settings-btn {
            position: relative;
        }
        
        /* Specific gradient backgrounds for certain buttons - now use accent colors */
        #updateNotesBtn {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border: none;
        }
        
        #resourcesBtn {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border: none;
        }
        
        #quizGeneratorBtn {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border: none;
        }
        
        #saveNotesBtn {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border: none;
        }
        
        #clearNotesBtn {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border: none;
        }
        
        .settings-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .settings-btn:hover {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            filter: brightness(1.2);
            transform: rotate(90deg) scale(1.05);
        }
        
        .settings-btn:active {
            filter: brightness(0.9);
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            padding: 0 2rem;
            gap: 1rem;
        }
        
        .tab {
            padding: 1rem 2rem;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #ccc;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .tab.active {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            color: #fff;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        
        .tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        
        /* Content Areas */
        .content {
            padding: 0;
            overflow: visible; /* Allow tooltips to show */
        }
        
        .assignments-content {
            display: none;
        }
        
        .assignments-content.active {
            display: block;
        }
        
        /* Main Menu */
        .main-menu {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: calc(100vh - 80px);
            padding: 0;
            padding-bottom: 0;
            overflow: hidden;
            position: relative;
        }
        
        .main-menu.active ~ * body,
        body:has(.main-menu:not(.hidden)) {
            overflow: hidden;
        }
        
        .menu-container {
            text-align: center;
            max-width: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 100%;
            position: relative;
        }
        
        .pie-menu-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 2rem;
            position: relative;
            height: 100%;
        }
        
        .pie-menu-arrows-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            position: relative;
        }
        
        .top-section-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
            margin-top: 3rem;
            animation: fadeInDown 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .top-section-title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            filter: brightness(0.7);
        }
        
        .top-section-button {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
            animation: buttonPulse 2s ease-in-out infinite;
        }
        
        .top-section-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2) 0%, transparent 50%);
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .top-section-button:hover {
            transform: scale(1.15) rotate(5deg);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.7);
            animation: none;
        }
        
        .top-section-button:hover::before {
            opacity: 0.4;
        }
        
        .top-section-button:active {
            transform: scale(1.08) rotate(-2deg);
        }
        
        @keyframes buttonPulse {
            0%, 100% {
                box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            }
            50% {
                box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
            }
        }
        
        .top-section-emoji {
            font-size: 4rem;
            position: relative;
            z-index: 1;
        }
        
        .top-section-description {
            font-size: 0.95rem;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: brightness(0.7);
            text-align: center;
            max-width: 250px;
            line-height: 1.4;
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .pie-menu {
            height: 800px;
            width: 800px;
            margin: 0;
            margin-bottom: -400px;
            position: relative;
            transition: transform 0.7s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @media (max-width: 1000px) {
            .pie-menu {
                height: 600px;
                width: 600px;
                margin-bottom: -300px;
            }
            .pie-menu-wrapper {
                gap: 2rem;
            }
        }
        
        @media (max-width: 600px) {
            .pie-menu {
                height: 400px;
                width: 400px;
                margin-bottom: -200px;
            }
            .pie-menu-wrapper {
                gap: 1rem;
            }
        }
        
        .pie-menu svg {
            width: 100%;
            height: 100%;
        }
        
        .pie-section {
            transition: all 0.3s ease;
        }
        
        .pie-slice {
            transition: all 0.3s ease;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }
        
        .pie-label {
            pointer-events: none;
            user-select: none;
            fill: var(--accent-color-1) !important;
            filter: brightness(0.7);
        }
        
        .pie-text-label {
            transition: font-size 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            fill: var(--accent-color-1) !important;
            filter: brightness(0.7);
        }
        
        .pie-emoji {
            transition: font-size 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .pie-section.pie-selected .pie-text-label {
            font-size: 26px;
            fill: var(--accent-color-2) !important;
            filter: brightness(0.7);
        }
        
        .pie-section.pie-selected .pie-emoji {
            font-size: 52px;
        }
        
        .gradient-stop1 {
            stop-color: var(--accent-color-1);
            stop-opacity: 1;
        }
        
        .gradient-stop2 {
            stop-color: var(--accent-color-2);
            stop-opacity: 1;
        }
        
        .menu-arrow {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            position: relative;
            z-index: 10;
        }
        
        .menu-arrow:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .menu-arrow:active {
            transform: scale(0.95);
        }
        
        .menu-arrow svg {
            width: 48px;
            height: 48px;
        }
        
        @media (max-width: 1000px) {
            .menu-arrow {
                width: 90px;
                height: 90px;
            }
            .menu-arrow svg {
                width: 36px;
                height: 36px;
            }
        }
        
        @media (max-width: 600px) {
            .menu-arrow {
                width: 60px;
                height: 60px;
            }
            .menu-arrow svg {
                width: 24px;
                height: 24px;
            }
        }
        
        .main-menu.hidden {
            display: none;
        }
        
        .notes-content {
            display: none;
        }
        
        .notes-content.active {
            display: block;
        }
        
        /* Assignment Cards */
        .assignment-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .assignment-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.2);
        }
        
        .assignment-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #fff;
        }
        
        .assignment-due {
            color: #aaa;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .assignment-status {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .status-submitted {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
        
        .status-missing {
            background: rgba(255, 0, 0, 0.2);
            color: #ff0000;
        }
        
        .status-upcoming {
            background: rgba(255, 255, 0, 0.2);
            color: #ffff00;
        }
        
        /* Course Grid */
        .course-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            padding: 2rem;
        }
        
        .course-card {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 2px solid rgba(102, 126, 234, 0.3);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border-radius: 24px;
            padding: 3rem;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            overflow: hidden;
        }
        
        .course-card::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.4) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
            z-index: 0;
        }
        
        .course-card:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .course-card:hover {
            background: rgba(102, 126, 234, 0.15);
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.4);
            border-color: rgba(102, 126, 234, 0.6);
        }
        
        .course-name {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #fff;
            letter-spacing: -0.01em;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        /* Add bubble particles on hover */
        .course-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(118, 75, 162, 0.2) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.4s ease;
            z-index: 0;
            pointer-events: none;
        }
        
        .course-card:hover::after {
            opacity: 1;
        }
        
        /* Split View */
        .split-view {
            display: none;
            height: calc(100vh - 120px);
            position: fixed;
            top: 120px;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            background: #000;
        }
        
        .split-view.active {
            display: flex;
        }
        
        .sidebar {
            width: 25%;
            background: rgba(255, 255, 255, 0.05);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            overflow-y: auto;
        }
        
        .unit {
            margin-bottom: 1.5rem;
        }
        
        .unit-title {
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background 0.3s ease;
        }
        
        .topic {
            position: relative;
            margin-left: 1rem;
            color: #ccc;
            cursor: pointer;
            padding: 0.5rem 0.75rem;
            border-radius: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .topic::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, rgba(102, 126, 234, 0.2) 0%, transparent 70%);
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: -1;
        }
        
        .topic:hover::before {
            opacity: 1;
        }
        
        .topic:hover {
            background: rgba(102, 126, 234, 0.15);
            color: #fff;
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .main-content {
            width: 75%;
            padding: 2rem;
            overflow-y: auto;
            max-height: 100%;
        }
        
        .notebook {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border-radius: 20px;
            padding: 2rem;
            user-select: none;
            font-size: var(--note-font-size);
        }
        
        .notebook h2 {
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        
        .notebook h3 {
            color: #00ff88;
            margin: 1.5rem 0 0.5rem;
            font-size: 1.2rem;
        }
        
        .notebook ul {
            margin-left: 1rem;
            margin-bottom: 1rem;
        }
        
        .notebook li {
            margin-bottom: 0.5rem;
            color: #e0e0e0;
        }
        
        .equation-box {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
        }
        
        /* Quiz styling */
        .quiz-question {
            margin: 1.5rem 0 0.8rem;
            padding: 1rem;
            background: rgba(102, 126, 234, 0.1);
            border-left: 3px solid var(--accent-color-1);
            border-radius: 8px;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        .quiz-option {
            margin: 0.5rem 0;
            padding-left: 2rem;
            padding-right: 1rem;
            color: #e0e0e0;
            line-height: 1.8;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .quiz-option:hover {
            background: rgba(102, 126, 234, 0.15);
            border-radius: 6px;
            padding-left: 2.5rem;
        }
        
        .quiz-answer {
            padding: 0.5rem 1rem;
            margin: 0.5rem 0;
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
            border-radius: 6px;
            font-weight: 600;
            color: #00ff88;
        }
        
        .quiz-question-wrapper {
            margin-bottom: 2rem;
        }
        
        .quiz-option.quiz-correct {
            background: rgba(0, 255, 136, 0.2);
            border-left: 3px solid #00ff88;
            color: #00ff88;
            font-weight: 600;
        }
        
        .quiz-option.quiz-wrong {
            background: rgba(255, 0, 0, 0.2);
            border-left: 3px solid #ff4444;
            color: #ff4444;
            animation: shake 0.5s ease;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .quiz-explanation {
            margin-top: 1rem;
            padding: 0.8rem 1rem;
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
            border-radius: 6px;
            color: #00ff88;
            font-style: italic;
            animation: fadeIn 0.3s ease;
        }
        
        .back-btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }
        
        .back-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }
        
        .back-to-menu-btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            margin-bottom: 1.5rem;
            margin-top: 1rem;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            align-self: flex-start;
            margin-left: 1rem;
        }
        
        .back-to-menu-btn:hover {
            transform: translateX(-5px) scale(1.05);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .back-to-menu-btn:active {
            transform: translateX(-3px) scale(1.02);
        }
        
        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            max-height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            padding-bottom: 2rem;
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }
        
        .settings-panel.active {
            right: 0;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.95);
            padding-bottom: 1rem;
            z-index: 10;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .close-settings {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .setting-group {
            margin-bottom: 2rem;
        }
        
        .setting-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #ccc;
        }
        
        .setting-input {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        /* Color Picker */
        .color-picker-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .color-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .color-circle:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .color-circle.active {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        .color-circle.image-upload {
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed rgba(0, 0, 0, 0.3);
        }
        
        .color-circle.image-upload:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(0, 0, 0, 0.5);
        }
        
        .upload-icon {
            font-size: 2rem;
            color: #000;
            font-weight: bold;
        }
        
        /* Small Color Picker for Text Colors */
        .color-picker-grid-small {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.6rem;
            margin-top: 0.5rem;
        }
        
        .color-circle-small {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .color-circle-small:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .color-circle-small.active {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }
        
        /* Note text color classes */
        .vocab-word {
            transition: all 0.3s ease;
        }
        
        .practice-problem {
            transition: all 0.3s ease;
        }
        
        .highlight-text {
            transition: all 0.3s ease;
        }
        
        .setting-select {
            width: 100%;
            padding: 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .setting-toggle {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .toggle {
            width: 50px;
            height: 25px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .toggle.active {
            background: #00ffff;
        }
        
        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 21px;
            height: 21px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        
        .toggle.active::after {
            transform: translateX(25px);
        }
        
        /* Loading Animation - Multiple Cool Styles */
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(108, 160, 255, 0.3);
            border-top: 4px solid #6ca0ff;
            border-right: 4px solid #4dd2ff;
            border-radius: 50%;
            animation: spinGlow 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
            margin: 0 auto;
            position: relative;
        }
        
        .loading-spinner::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            border: 2px solid transparent;
            border-top-color: #6ca0ff;
            animation: spinGlow 0.8s linear infinite reverse;
        }
        
        .loading-spinner::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            margin: -6px 0 0 -6px;
            background: radial-gradient(circle, #6ca0ff, #4dd2ff);
            border-radius: 50%;
            animation: pulseCenter 1s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(108, 160, 255, 0.8);
        }
        
        @keyframes spinGlow {
            0% { 
                transform: rotate(0deg);
                box-shadow: 0 0 10px rgba(108, 160, 255, 0.5);
            }
            100% { 
                transform: rotate(360deg);
                box-shadow: 0 0 20px rgba(108, 160, 255, 0.8);
            }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulseCenter {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.3);
                opacity: 0.7;
            }
        }
        
        /* Loading Progress Dots */
        .loading-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
        }
        
        .loading-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6ca0ff, #4dd2ff);
            animation: dotPulse 1.4s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(108, 160, 255, 0.6);
        }
        
        .loading-dot:nth-child(1) { animation-delay: 0s; }
        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes dotPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 0.7;
            }
        }
        
        /* Loading Wave */
        .loading-wave {
            display: flex;
            justify-content: center;
            gap: 4px;
            height: 30px;
            align-items: center;
        }
        
        .loading-wave-bar {
            width: 4px;
            background: linear-gradient(180deg, #6ca0ff, #4dd2ff);
            border-radius: 2px;
            animation: waveAnimation 1.2s ease-in-out infinite;
            box-shadow: 0 0 8px rgba(108, 160, 255, 0.5);
        }
        
        .loading-wave-bar:nth-child(1) { animation-delay: 0s; height: 15px; }
        .loading-wave-bar:nth-child(2) { animation-delay: 0.1s; height: 25px; }
        .loading-wave-bar:nth-child(3) { animation-delay: 0.2s; height: 30px; }
        .loading-wave-bar:nth-child(4) { animation-delay: 0.3s; height: 25px; }
        .loading-wave-bar:nth-child(5) { animation-delay: 0.4s; height: 15px; }
        
        @keyframes waveAnimation {
            0%, 100% {
                transform: scaleY(1);
                opacity: 0.7;
            }
            50% {
                transform: scaleY(1.8);
                opacity: 1;
            }
        }
        
        /* Loading Orb */
        .loading-orb {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 20px auto;
            position: relative;
            background: radial-gradient(circle, #6ca0ff, #4dd2ff);
            animation: orbFloat 2s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(108, 160, 255, 0.6), inset 0 0 30px rgba(255, 255, 255, 0.3);
        }
        
        .loading-orb::before {
            content: '';
            position: absolute;
            top: 15%;
            left: 20%;
            width: 30%;
            height: 30%;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
        }
        
        @keyframes orbFloat {
            0%, 100% {
                transform: translateY(0) scale(1);
            }
            50% {
                transform: translateY(-20px) scale(1.1);
            }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .token-input {
                width: 90%;
                max-width: 400px;
            }
            
            .course-grid {
                grid-template-columns: 1fr;
            }
            
            .split-view {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 200px;
            }
            
            .main-content {
                width: 100%;
            }
            
            .settings-panel {
                width: 100%;
                right: -100%;
            }
        }
        
        /* Add clearer outline to file upload area and buttons */
        #fileUploadArea {
            border: 2px dashed rgba(255,255,255,0.25);
            border-radius: 10px;
            padding: 1rem;
        }
        #fileUploadArea:focus-within {
            outline: 3px solid #6ca0ff;
            outline-offset: 2px;
        }
        #generateFromFilesBtn, #testExtractionBtn {
            border: 2px solid rgba(255,255,255,0.35);
        }
        #generateFromFilesBtn:focus, #testExtractionBtn:focus,
        #generateFromFilesBtn:hover, #testExtractionBtn:hover {
            outline: 3px solid #6ca0ff;
            outline-offset: 2px;
        }
        /* Progress bar for generation */
        .gen-progress {
            width: 100%;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            height: 12px;
            overflow: hidden;
            margin-top: 8px;
        }
        .gen-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #6ca0ff, #4dd2ff);
            transition: width 0.35s ease;
        }
        .gen-progress-wrap {
            padding: 12px 14px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            background: rgba(255,255,255,0.05);
            margin: 12px 0 16px;
        }
        .gen-progress-title {
            font-size: 0.9rem;
            color: #cfd8ff;
        }
        /* Per-unit topic progress */
        .topic-progress-wrap {
            padding: 10px 12px;
            border: 1px dashed rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.03);
            margin: 8px 0 12px;
        }
        .topic-progress-title { font-size: 0.85rem; color: #cfd8ff; }
        .topic-progress { width: 100%; height: 8px; background: rgba(255,255,255,0.08); border-radius: 6px; overflow: hidden; margin-top: 6px; }
        .topic-progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #8cb4ff, #6ce0ff); transition: width 0.3s ease; }
        /* Topic page container */
        #topicPageContainer { margin-top: 8px; }
        .topic-page { 
            display: none; 
            animation: fadeIn 0.4s ease-in-out;
            padding: 2rem;
        }
        .topic-page.active { display: block; }
        
        /* Disable clicking unit titles; only topics are clickable */
        .unit-title { pointer-events: none; cursor: default; }
        
        /* Smooth animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.02); opacity: 0.9; }
        }
        
        @keyframes shimmer {
            0% { background-position: -1000px 0; }
            100% { background-position: 1000px 0; }
        }
        
        /* Enhanced text rendering with proper formatting */
        .topic-page-content {
            line-height: 1.8;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .topic-page-content h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 2rem 0 1rem 0;
            color: #6ca0ff;
            text-shadow: 0 0 20px rgba(108, 160, 255, 0.3);
            animation: slideInRight 0.5s ease-out;
        }
        
        .topic-page-content h4 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 1.5rem 0 0.75rem 0;
            color: #4dd2ff;
        }
        
        .topic-page-content ul, .topic-page-content ol {
            margin: 0.75rem 0;
            padding-left: 2rem;
        }
        
        .topic-page-content li {
            margin: 0.5rem 0;
            animation: fadeIn 0.3s ease-out forwards;
            opacity: 0;
        }
        
        .topic-page-content li:nth-child(1) { animation-delay: 0.05s; }
        .topic-page-content li:nth-child(2) { animation-delay: 0.1s; }
        .topic-page-content li:nth-child(3) { animation-delay: 0.15s; }
        .topic-page-content li:nth-child(4) { animation-delay: 0.2s; }
        .topic-page-content li:nth-child(5) { animation-delay: 0.25s; }
        .topic-page-content li:nth-child(6) { animation-delay: 0.3s; }
        .topic-page-content li:nth-child(7) { animation-delay: 0.35s; }
        
        .topic-page-content strong, .topic-page-content b {
            font-weight: 700;
            position: relative;
        }
        
        .topic-page-content p {
            margin: 1rem 0;
            text-align: justify;
        }
        
        .topic-page-content pre, .topic-page-content code {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.75rem;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            animation: fadeIn 0.4s ease-out;
        }
        
        .topic-page-content blockquote {
            border-left: 4px solid #6ca0ff;
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: rgba(255, 255, 255, 0.8);
            animation: slideInRight 0.5s ease-out;
        }
        
        .topic-page-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            animation: fadeIn 0.5s ease-out;
        }
        
        .topic-page-content td, .topic-page-content th {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.75rem;
            text-align: left;
        }
        
        .topic-page-content th {
            background: rgba(108, 160, 255, 0.2);
            font-weight: 600;
        }
        
        /* Enhanced vocab and practice styling */
        .vocab-word, .practice-problem {
            position: relative;
            border-radius: 3px;
            transition: all 0.3s ease;
        }
        
        .vocab-word:hover, .practice-problem:hover {
            padding: 2px 4px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        /* Smooth sidebar transitions */
        .sidebar {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .topic {
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .topic::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(108, 160, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .topic:hover::before {
            left: 100%;
        }
        
        .topic:hover {
            background: rgba(108, 160, 255, 0.15);
            transform: translateX(5px);
        }
        
        /* Course card improvements */
        .course-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .course-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(108, 160, 255, 0.1), rgba(77, 210, 255, 0.1));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .course-card:hover::after {
            opacity: 1;
        }
        
        .course-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 10px 30px rgba(108, 160, 255, 0.3);
        }
        
        /* Button enhancements */
        button, .btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        button::before, .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before, .btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        button:hover, .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 160, 255, 0.4);
        }
        
        button:active, .btn:active {
            transform: translateY(0);
        }
        
        /* Progress bar animations */
        .gen-progress-fill, .topic-progress-fill {
            position: relative;
            overflow: hidden;
        }
        
        .gen-progress-fill::after, .topic-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }
        
        /* Additional cool animations */
        @keyframes scaleIn {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes rotateIn {
            from { transform: rotate(-180deg); opacity: 0; }
            to { transform: rotate(0deg); opacity: 1; }
        }
        
        @keyframes glowPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(108, 160, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(108, 160, 255, 0.8), 0 0 30px rgba(77, 210, 255, 0.6); }
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Animate color circles on settings change */
        .color-circle-small.active {
            animation: scaleIn 0.3s ease-out, glowPulse 2s infinite;
        }
        
        .color-circle.active {
            animation: scaleIn 0.3s ease-out, glowPulse 2s infinite;
        }
        
        /* Gradient circle styles */
        .gradient-circle {
            transition: all 0.3s ease;
        }
        
        .gradient-circle:hover {
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(108, 160, 255, 0.6);
        }
        
        /* Loading spinner uses the enhanced version defined earlier */
        
        /* File upload area */
        #fileUploadArea {
            animation: slideUp 0.5s ease-out;
        }
        
        /* Sidebar animation */
        #unitsList .unit {
            animation: fadeIn 0.4s ease-out forwards;
            opacity: 0;
        }
        
        #unitsList .unit:nth-child(1) { animation-delay: 0.1s; }
        #unitsList .unit:nth-child(2) { animation-delay: 0.15s; }
        #unitsList .unit:nth-child(3) { animation-delay: 0.2s; }
        #unitsList .unit:nth-child(4) { animation-delay: 0.25s; }
        #unitsList .unit:nth-child(5) { animation-delay: 0.3s; }
        
        /* Settings modal */
        .settings-modal {
            animation: scaleIn 0.3s ease-out;
        }
        
        /* Course grid */
        .course-card {
            animation: fadeIn 0.5s ease-out forwards;
            opacity: 0;
        }
        
        .course-card:nth-child(1) { animation-delay: 0.05s; }
        .course-card:nth-child(2) { animation-delay: 0.1s; }
        .course-card:nth-child(3) { animation-delay: 0.15s; }
        .course-card:nth-child(4) { animation-delay: 0.2s; }
        .course-card:nth-child(5) { animation-delay: 0.25s; }
        .course-card:nth-child(6) { animation-delay: 0.3s; }
        .course-card:nth-child(7) { animation-delay: 0.35s; }
        .course-card:nth-child(8) { animation-delay: 0.4s; }
        .course-card:nth-child(9) { animation-delay: 0.45s; }
        
        /* Notebook header */
        #notebook h2 {
            animation: slideInRight 0.6s ease-out;
        }
        
        /* Close buttons */
        .close-settings {
            transition: all 0.3s ease;
        }
        
        .close-settings:hover {
            transform: rotate(90deg);
            animation: glowPulse 1s ease-in-out infinite;
        }
        
        /* Save button special effects */
        #saveNotesBtn {
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        #saveNotesBtn:hover {
            animation: bounce 1s ease-in-out infinite;
        }
        
        /* Color picker hover effects */
        .color-circle-small, .color-circle {
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        .color-circle-small:hover, .color-circle:hover {
            animation: bounce 0.6s ease-in-out infinite;
        }
        
        /* Settings panel smooth entry */
        .settings-modal {
            backdrop-filter: blur(10px);
        }
        
        /* Text color indicators */
        .vocab-word, .practice-problem {
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        /* Settings group animations */
        .setting-group {
            animation: fadeIn 0.5s ease-out forwards;
            opacity: 0;
        }
        
        .setting-group:nth-child(1) { animation-delay: 0.1s; }
        .setting-group:nth-child(2) { animation-delay: 0.2s; }
        .setting-group:nth-child(3) { animation-delay: 0.3s; }
        .setting-group:nth-child(4) { animation-delay: 0.4s; }
        .setting-group:nth-child(5) { animation-delay: 0.5s; }
    </style>
</head>
<body>
    <!-- Instructions Overlay -->
    <div class="instructions-overlay" id="instructionsOverlay"></div>
    
    <!-- Welcome Screen -->
    <div class="welcome-screen hidden" id="welcomeScreen">
        <div class="welcome-message" id="welcomeMessage">Hello,</div>
    </div>
    
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="logo">ðŸŽ“ Canvas Learning Assistant</div>
        <input type="text" class="token-input" id="tokenInput" placeholder="Paste your Canvas Access Token here">
        <div class="instruction-text">Paste your Canvas Access Token to begin. Your data stays on your device.</div>
        <div class="instructions-toggle" id="instructionsToggle">ðŸ“– Need help? Click here for detailed instructions</div>
        <div class="instructions-panel" id="instructionsPanel">
            <button class="instructions-close" id="instructionsClose">Ã—</button>
            <div style="overflow-y: auto; overflow-x: hidden; max-height: calc(80vh - 4rem); padding-right: 0.5rem; -webkit-overflow-scrolling: touch;">
                <h3>ðŸ“š Getting Started Guide</h3>
                
                <h4>ðŸ”‘ Step 1: Get Your Canvas Access Token</h4>
            <ol>
                <li>Log into your Canvas account at your school's Canvas URL (e.g., <code>yourschool.instructure.com</code>)</li>
                <li>Click on your profile picture or name in the top-left corner</li>
                <li>Select <strong>"Settings"</strong> from the dropdown menu</li>
                <li>Scroll down to the <strong>"Approved Integrations"</strong> section</li>
                <li>Click the <strong>"+ New Access Token"</strong> button</li>
                <li>Give your token a descriptive name (e.g., "Learning Assistant")</li>
                <li>Optionally set an expiration date (or leave blank for no expiration)</li>
                <li>Click <strong>"Generate Token"</strong></li>
                <li><strong>IMPORTANT:</strong> Copy the token immediately - you won't be able to see it again! It will look like a long string of letters and numbers.</li>
                <li>Paste the token into the input box above</li>
            </ol>
            
            <h4>ðŸ“¥ Step 2: Download Course Content from Canvas</h4>
            <ol>
                <li>Navigate to the course you want to download</li>
                <li>In the left sidebar, click on <strong>"Modules"</strong></li>
                <li>Once you're in Modules, look for the Cousre Content Export Butotn at top</li>
                <li>Click on <strong>"Course Content Export"</strong> </li>
                <li>Select <strong>"Course"</strong> as the export type</li>
                <li>Click <strong>"Create Export"</strong> or <strong>"Export Course Content"</strong></li>
                <li>Wait for Canvas to prepare the export (this may take a few minutes)</li>
                <li>You'll receive an email notification when it's ready, OR refresh the page</li>
                <li>Once ready, click the <strong>"New Export"</strong> link or the download icon</li>
                <li>This will download a ZIP file containing all course content</li>
            </ol>
            
            <h4>ðŸ“¤ Step 3: Upload to This App</h4>
            <ol>
                <li>After clicking "Load My Courses", select your course from the grid</li>
                <li>Click the file upload area or select files from your computer</li>
                <li>You can upload:
                    <ul>
                        <li>ZIP files (entire course exports from Canvas)</li>
                        <li>Individual PDF, PowerPoint (PPT/PPTX), Word (DOC/DOCX), or Text (TXT) files</li>
                    </ul>
                </li>
                <li>Click <strong>"Generate AI Notes from Files"</strong> to create your study notes</li>
            </ol>
            
            <p style="color: rgba(255, 255, 255, 0.7); font-size: 0.9rem; margin-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 1rem;">
                <strong>ðŸ’¡ Tip:</strong> The ZIP file method is fastest if you want notes for the entire course. Individual files work great for specific topics or modules.
            </p>
            </div>
        </div>
        <button class="load-btn" id="loadBtn">Load My Courses</button>
    </div>

    <!-- Main Dashboard -->
    <div class="dashboard" id="dashboard">
        <div class="header">
            <h1>ðŸŽ“ Learning Assistant</h1>
            <div class="header-buttons">
                <button class="header-btn" id="saveNotesBtn" data-tooltip="Save Notes">ðŸ’¾<span class="tooltip">Save Notes</span></button>
                <button class="header-btn" id="clearNotesBtn" data-tooltip="Clear Notes">ðŸ—‘ï¸<span class="tooltip">Clear Notes</span></button>
                <button class="header-btn" id="updateNotesBtn" data-tooltip="Update Notes">ðŸ”„<span class="tooltip">Update Notes</span></button>
                <button class="header-btn" id="resourcesBtn" data-tooltip="Resources">ðŸ“<span class="tooltip">Resources</span></button>
                <button class="header-btn" id="quizGeneratorBtn" data-tooltip="Generate Quiz">ðŸ“<span class="tooltip">Generate Quiz</span></button>
                <button class="header-btn" id="flashcardBtn" data-tooltip="Flashcards">ðŸƒ<span class="tooltip">Flashcards</span></button>
                <button class="settings-btn" id="settingsBtn" data-tooltip="Settings">âš™ï¸<span class="tooltip">Settings</span></button>
            </div>
        </div>
        
        <div class="content">
            <!-- Main Menu -->
            <div class="main-menu" id="mainMenu">
                <div class="menu-container">
                    <div class="pie-menu-wrapper">
                        <!-- Top Section Info Button -->
                        <div class="top-section-info" id="topSectionInfo" style="display: none;">
                            <div class="top-section-title" id="topSectionTitle"></div>
                            <button class="top-section-button" id="topSectionButton">
                                <span class="top-section-emoji" id="topSectionEmoji"></span>
                            </button>
                            <div class="top-section-description" id="topSectionDescription"></div>
                        </div>
                        
                        <div class="pie-menu-arrows-wrapper">
                            <!-- Left Arrow -->
                            <button class="menu-arrow menu-arrow-left" id="menuArrowLeft">
                                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M15 18l-6-6 6-6"/>
                                </svg>
                            </button>
                            
                            <!-- Pie Menu Circle -->
                            <div class="pie-menu" id="pieMenu">
                            <svg width="800" height="800" viewBox="0 0 400 400">
                                <defs>
                                    <linearGradient id="pieGradient1" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" class="gradient-stop1" />
                                        <stop offset="100%" class="gradient-stop2" />
                                    </linearGradient>
                                    <linearGradient id="pieGradient2" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" class="gradient-stop2" />
                                        <stop offset="100%" class="gradient-stop1" />
                                    </linearGradient>
                                </defs>
                                
                                <!-- Background Circle -->
                                <circle cx="200" cy="200" r="180" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="2"/>
                                
                                <!-- Section 1: Classes (Top-Right - center at 45Â°) -->
                                <g class="pie-section pie-selected" id="classesSectionGroup">
                                    <path id="classesSection" class="pie-slice" d="M 200 200 L 200 20 A 180 180 0 0 1 380 200 Z" 
                                          fill="url(#pieGradient1)" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>
                                    <text x="299" y="101" text-anchor="middle" class="pie-label" font-size="20" font-weight="600" transform="rotate(45 299 101)">
                                        <tspan x="299" dy="0" class="pie-text-label">Classes</tspan>
                                        <tspan x="299" dy="50" font-size="36" class="pie-emoji">ðŸ“š</tspan>
                                    </text>
                                </g>
                                
                                <!-- Section 2: Calendar (Bottom-Right - center at 135Â°) -->
                                <g class="pie-section" id="calendarSectionGroup">
                                    <path id="calendarSection" class="pie-slice" d="M 200 200 L 380 200 A 180 180 0 0 1 200 380 Z" 
                                          fill="url(#pieGradient2)" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>
                                    <text x="299" y="299" text-anchor="middle" class="pie-label" font-size="20" font-weight="600" transform="rotate(135 299 299)">
                                        <tspan x="299" dy="0" class="pie-text-label">Calendar</tspan>
                                        <tspan x="299" dy="50" font-size="36" class="pie-emoji">ðŸ“…</tspan>
                                    </text>
                                </g>
                                
                                <!-- Section 3: (Bottom-Left - center at 225Â°) -->
                                <g class="pie-section" id="section3Group">
                                    <path id="section3" class="pie-slice" d="M 200 200 L 200 380 A 180 180 0 0 1 20 200 Z" 
                                          fill="url(#pieGradient1)" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>
                                    <text x="101" y="299" text-anchor="middle" class="pie-label" font-size="20" font-weight="600" transform="rotate(225 101 299)">
                                        <tspan x="101" dy="0" class="pie-text-label">Section</tspan>
                                        <tspan x="101" dy="25" class="pie-text-label">3</tspan>
                                        <tspan x="101" dy="50" font-size="36" class="pie-emoji">ðŸ“‹</tspan>
                                    </text>
                                </g>
                                
                                <!-- Section 4: (Top-Left - center at 315Â°/-45Â°) -->
                                <g class="pie-section" id="section4Group">
                                    <path id="section4" class="pie-slice" d="M 200 200 L 20 200 A 180 180 0 0 1 200 20 Z" 
                                          fill="url(#pieGradient2)" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>
                                    <text x="101" y="101" text-anchor="middle" class="pie-label" font-size="20" font-weight="600" transform="rotate(-45 101 101)">
                                        <tspan x="101" dy="0" class="pie-text-label">Section</tspan>
                                        <tspan x="101" dy="25" class="pie-text-label">4</tspan>
                                        <tspan x="101" dy="50" font-size="36" class="pie-emoji">ðŸ“Š</tspan>
                                    </text>
                                </g>
                                
                                <!-- Center Circle -->
                                <circle cx="200" cy="200" r="60" fill="rgba(0,0,0,0.3)" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>
                            </svg>
                            </div>
                            
                            <!-- Right Arrow -->
                            <button class="menu-arrow menu-arrow-right" id="menuArrowRight">
                                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M9 18l6-6-6-6"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Notes Content -->
            <div class="notes-content" id="notesContent" style="display: none;">
                <div style="padding: 1rem;">
                    <button class="back-to-menu-btn" id="backToMenuBtn">â† Back to Menu</button>
                </div>
                <div class="course-grid" id="courseGrid"></div>
            </div>
        </div>
    </div>

    <!-- Split View for Course Notes -->
    <div class="split-view" id="splitView">
        <div class="sidebar" id="sidebar">
            <button class="back-btn" id="backBtn">â† Back to Courses</button>
            <div id="unitsList"></div>
        </div>
        <div class="main-content" id="mainContent">
            <!-- File Upload Area -->
            <div class="file-upload-area" id="fileUploadArea" style="display: none;">
                <div class="file-zone">
                    <h3>ðŸ“‚ Upload Course Files</h3>
                    <p>Upload your course ZIP file or individual files (PDF, PPT, DOC, TXT)</p>
                    <p style="color: #aaa; font-size: 0.9rem; margin-top: 1rem;">
                        Canvas downloads come as ZIP files - we'll extract them automatically!
                    </p>
                </div>
                <button class="btn btn-primary" id="generateFromFilesBtn" style="display: none;">ðŸ¤– Generate AI Notes from Files</button>
                <button class="btn btn-secondary" id="testExtractionBtn" style="display: none; margin-left: 1rem;">ðŸ” Test Text Extraction</button>
            </div>
            
            <!-- Notebook Content -->
            <div class="notebook" id="notebook"></div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h2>Settings</h2>
            <button class="close-settings" id="closeSettings">Ã—</button>
        </div>
        
        
        <div class="setting-group">
            <label class="setting-label">Background Color</label>
            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.5rem;">
                <input type="color" id="backgroundColorPicker" value="#000000" style="width: 60px; height: 40px; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer;">
                <div id="backgroundColorDisplay" style="width: 40px; height: 40px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.5); background: #000000;"></div>
                <div class="color-circle image-upload" id="backgroundImageUpload" title="Upload Custom Background" style="width: 40px; height: 40px;">
                    <input type="file" id="backgroundImageInput" accept="image/*" style="display: none;">
                    <span class="upload-icon">+</span>
                </div>
            </div>
            <div style="margin-top: 1rem;">
                <label class="setting-label" style="font-size: 0.9rem; margin-bottom: 0.5rem;">Gradient Background</label>
                <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.5rem;">
                    <div id="backgroundGradientDisplay" style="width: 60px; height: 40px; border: 2px solid rgba(255,255,255,0.5); border-radius: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); cursor: pointer; position: relative;" title="Click to select gradient">
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.8rem; color: rgba(255,255,255,0.8);">G</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                        <div class="gradient-circle" data-gradient="linear-gradient(135deg, #667eea 0%, #764ba2 100%)" style="width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.5); background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                        <div class="gradient-circle" data-gradient="linear-gradient(135deg, #f093fb 0%, #f5576c 100%)" style="width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.5); background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);"></div>
                        <div class="gradient-circle" data-gradient="linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)" style="width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.5); background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);"></div>
                        <div class="gradient-circle" data-gradient="linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)" style="width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.5); background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);"></div>
                        <div class="gradient-circle" data-gradient="linear-gradient(135deg, #fa709a 0%, #fee140 100%)" style="width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.5); background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);"></div>
                        <div class="gradient-circle" data-gradient="linear-gradient(135deg, #30cfd0 0%, #330867 100%)" style="width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.5); background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="setting-group">
            <label class="setting-label">Note Text Colors</label>
            
            <div style="margin-bottom: 1.5rem;">
                <label class="setting-label" style="font-size: 0.9rem; margin-bottom: 0.5rem;">Vocab Words</label>
                <select class="setting-select" id="vocabStyle" style="margin-bottom: 0.5rem;">
                    <option value="color">Color the Text</option>
                    <option value="highlight">Highlight Background</option>
                </select>
                <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.5rem;">
                    <input type="color" id="vocabColorPicker" value="#00008b" style="width: 60px; height: 40px; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer;">
                    <div id="vocabColorDisplay" style="width: 40px; height: 40px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.5); background: #00008b;"></div>
                </div>
            </div>
            
            <div style="margin-bottom: 1.5rem;">
                <label class="setting-label" style="font-size: 0.9rem; margin-bottom: 0.5rem;">Practice Problems</label>
                <select class="setting-select" id="practiceStyle" style="margin-bottom: 0.5rem;">
                    <option value="color">Color the Text</option>
                    <option value="highlight">Highlight Background</option>
                </select>
                <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.5rem;">
                    <input type="color" id="practiceColorPicker" value="#006400" style="width: 60px; height: 40px; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; cursor: pointer;">
                    <div id="practiceColorDisplay" style="width: 40px; height: 40px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.5); background: #006400;"></div>
                </div>
            </div>
        </div>
        
        <div class="setting-group">
            <label class="setting-label">Font Size</label>
            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.5rem;">
                <input type="range" id="fontSizeSlider" min="12" max="24" value="16" step="1" style="flex: 1; height: 6px; border-radius: 5px; outline: none; background: rgba(255,255,255,0.2); cursor: pointer;">
                <span id="fontSizeDisplay" style="min-width: 40px; text-align: center; font-weight: 600;">16px</span>
            </div>
        </div>
        
        <div class="setting-group">
            <label class="setting-label">Enable Animations</label>
            <div class="setting-toggle">
                <div class="toggle active" id="animationsToggle"></div>
                <span>On</span>
            </div>
        </div>
        
        <div class="setting-group" style="margin-top: 3rem; padding-top: 2rem; border-top: 2px solid rgba(255, 255, 255, 0.2);">
            <label class="setting-label" style="color: #ff6b6b; font-weight: 600;">âš ï¸ Danger Zone</label>
            <p style="color: rgba(255, 255, 255, 0.6); font-size: 0.9rem; margin: 0.5rem 0 1rem 0;">
                This will permanently delete all saved data including notes, quizzes, resources, settings, and your Canvas token.
            </p>
            <button class="btn btn-secondary" id="clearAllDataBtn" style="
                width: 100%;
                padding: 0.9rem;
                background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
                border: none;
                color: #fff;
                font-weight: 600;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
            ">ðŸ—‘ï¸ Clear All Data</button>
        </div>
    </div>

    <script>
        // Global variables
        let canvasToken = '';
        let currentCourses = [];
        let currentCourse = null;
        let savedNotes = {};
        let selectedFiles = [];
        let courseResources = {}; // Store resources per course
        let settings = {
            animations: true,
            backgroundColor: '#000000',
            backgroundImage: null,
            backgroundGradient: null,
            vocabColor: '#00008b',
            vocabStyle: 'color',
            practiceColor: '#006400',
            practiceStyle: 'color',
            fontSize: 16
        };
        let lastUsedFiles = [];
        let lastGenerationTime = 0;
        const GENERATION_COOLDOWN = 90000; // 90 seconds (1 minute 30 seconds)

        // DOM elements
        const loadingScreen = document.getElementById('loadingScreen');
        const dashboard = document.getElementById('dashboard');
        const tokenInput = document.getElementById('tokenInput');
        const loadBtn = document.getElementById('loadBtn');
        const notesContent = document.getElementById('notesContent');
        const courseGrid = document.getElementById('courseGrid');
        const splitView = document.getElementById('splitView');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('mainContent');
        const notebook = document.getElementById('notebook');
        const backBtn = document.getElementById('backBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettings = document.getElementById('closeSettings');
        const mainMenu = document.getElementById('mainMenu');
        const classesBtn = document.getElementById('classesBtn');
        const calendarBtn = document.getElementById('calendarBtn');
        const animationsToggle = document.getElementById('animationsToggle');
        const fileUploadArea = document.getElementById('fileUploadArea');
        const generateFromFilesBtn = document.getElementById('generateFromFilesBtn');
        const testExtractionBtn = document.getElementById('testExtractionBtn');
        const clearNotesBtn = document.getElementById('clearNotesBtn');
        const saveNotesBtn = document.getElementById('saveNotesBtn');
        const resourcesBtn = document.getElementById('resourcesBtn');
        const quizGeneratorBtn = document.getElementById('quizGeneratorBtn');
        const flashcardBtn = document.getElementById('flashcardBtn');
        const vocabStyle = document.getElementById('vocabStyle');
        const practiceStyle = document.getElementById('practiceStyle');
        const vocabColorPicker = document.getElementById('vocabColorPicker');
        const practiceColorPicker = document.getElementById('practiceColorPicker');
        const vocabColorDisplay = document.getElementById('vocabColorDisplay');
        const practiceColorDisplay = document.getElementById('practiceColorDisplay');
        const backgroundColorPicker = document.getElementById('backgroundColorPicker');
        const backgroundColorDisplay = document.getElementById('backgroundColorDisplay');
        const fontSizeSlider = document.getElementById('fontSizeSlider');
        const fontSizeDisplay = document.getElementById('fontSizeDisplay');

        // Initialize app
        function init() {
            // Load saved settings
            const savedSettings = localStorage.getItem('canvasSettings');
            if (savedSettings) {
                try {
                    const parsed = JSON.parse(savedSettings);
                    settings = { ...settings, ...parsed };
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
            
            // Load dropdown values
            if (vocabStyle) vocabStyle.value = settings.vocabStyle || 'color';
            if (practiceStyle) practiceStyle.value = settings.practiceStyle || 'color';
            
            // Load color picker values
            if (vocabColorPicker) vocabColorPicker.value = settings.vocabColor || '#00008b';
            if (practiceColorPicker) practiceColorPicker.value = settings.practiceColor || '#006400';
            if (backgroundColorPicker) backgroundColorPicker.value = settings.backgroundColor || '#000000';
            if (vocabColorDisplay) vocabColorDisplay.style.background = settings.vocabColor || '#00008b';
            if (practiceColorDisplay) practiceColorDisplay.style.background = settings.practiceColor || '#006400';
            if (backgroundColorDisplay) backgroundColorDisplay.style.background = settings.backgroundColor || '#000000';
            
            // Load gradient display
            const backgroundGradientDisplay = document.getElementById('backgroundGradientDisplay');
            if (backgroundGradientDisplay) {
                if (settings.backgroundGradient) {
                    backgroundGradientDisplay.style.background = settings.backgroundGradient;
                    const label = backgroundGradientDisplay.querySelector('div');
                    if (label) label.style.display = 'none';
                } else {
                    backgroundGradientDisplay.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    const label = backgroundGradientDisplay.querySelector('div');
                    if (label) label.style.display = 'block';
                }
            }
            
            // Highlight active gradient circle
            if (settings.backgroundGradient) {
                const gradientCircles = document.querySelectorAll('.gradient-circle');
                gradientCircles.forEach(circle => {
                    if (circle.getAttribute('data-gradient') === settings.backgroundGradient) {
                        circle.style.border = '2px solid #6ca0ff';
                    }
                });
            }
            
            // Apply background on load (after all settings are loaded)
            applyBackground();
            updateColorPickerSelection();
            
            // Load font size
            if (fontSizeSlider) fontSizeSlider.value = settings.fontSize || 16;
            if (fontSizeDisplay) fontSizeDisplay.textContent = `${settings.fontSize || 16}px`;
            applyFontSize();
            
            // Apply text colors after loading all values
            applyTextColors();

            // Load saved notes with error handling
            savedNotes = safeLoadNotes();
            // Log what was loaded for debugging
            const noteCount = Object.keys(savedNotes).length;
            console.log(`Initialized: Loaded ${noteCount} course(s) with saved notes`);
            if (noteCount > 0) {
                Object.keys(savedNotes).forEach(courseId => {
                    const notes = savedNotes[courseId];
                    console.log(`  Course ${courseId}: ${notes.units?.length || 0} units, content length: ${notes.content?.length || 0}`);
                });
            }
            
            // Load resources
            loadResources();

            // Load saved token
            const savedToken = localStorage.getItem('canvasToken');
            if (savedToken) {
                canvasToken = sanitizeHeaderValue(savedToken);
                // Auto-load with welcome screen
                autoLoadWithWelcome();
            } else {
                loadingScreen.classList.remove('hidden');
            }

            // Setup event listeners
            setupEventListeners();
        }

        function setupEventListeners() {
            // Instructions toggle
            const instructionsToggle = document.getElementById('instructionsToggle');
            const instructionsPanel = document.getElementById('instructionsPanel');
            const instructionsOverlay = document.getElementById('instructionsOverlay');
            const instructionsClose = document.getElementById('instructionsClose');
            
            function openInstructions() {
                instructionsPanel.classList.add('active');
                instructionsOverlay.classList.add('active');
                // Don't prevent body scrolling - allow background to scroll
            }
            
            function closeInstructions() {
                instructionsPanel.classList.remove('active');
                instructionsOverlay.classList.remove('active');
            }
            
            if (instructionsToggle && instructionsPanel && instructionsOverlay) {
                instructionsToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (instructionsPanel.classList.contains('active')) {
                        closeInstructions();
                    } else {
                        openInstructions();
                    }
                });
                
                // Close button
                if (instructionsClose) {
                    instructionsClose.addEventListener('click', (e) => {
                        e.stopPropagation();
                        closeInstructions();
                    });
                }
                
                // Don't close when clicking outside - user needs to use X button
            }
            
            loadBtn.addEventListener('click', handleLoadCourses);
            
            // Pie menu navigation
            let currentRotation = -45; // Start at -45deg so slice center points up
            const pieMenu = document.getElementById('pieMenu');
            const menuArrowLeft = document.getElementById('menuArrowLeft');
            const menuArrowRight = document.getElementById('menuArrowRight');
            
        // Set initial rotation
        if (pieMenu) {
            pieMenu.style.transform = `rotate(${currentRotation}deg)`;
        }
            
            // Arrow navigation - rotate 90 degrees (one quarter turn)
            if (menuArrowLeft) {
                menuArrowLeft.addEventListener('click', () => {
                    currentRotation -= 90;
                    if (pieMenu) {
                        pieMenu.style.transform = `rotate(${currentRotation}deg)`;
                    }
                    updateSelectedSection();
                });
            }
            
            if (menuArrowRight) {
                menuArrowRight.addEventListener('click', () => {
                    currentRotation += 90;
                    if (pieMenu) {
                        pieMenu.style.transform = `rotate(${currentRotation}deg)`;
                    }
                    updateSelectedSection();
                });
            }
            
            // Section data for display
            const sectionData = {
                classes: {
                    title: 'Classes',
                    emoji: 'ðŸ“š',
                    description: 'View and manage your course classes'
                },
                calendar: {
                    title: 'Calendar',
                    emoji: 'ðŸ“…',
                    description: 'Coming soon - View your schedule'
                },
                section3: {
                    title: 'Section 3',
                    emoji: 'ðŸ“‹',
                    description: 'Coming soon'
                },
                section4: {
                    title: 'Section 4',
                    emoji: 'ðŸ“Š',
                    description: 'Coming soon'
                }
            };
            
            // Update selected section based on rotation
            const updateSelectedSection = () => {
                // Remove all selected classes
                const allSections = document.querySelectorAll('.pie-section');
                allSections.forEach(section => section.classList.remove('pie-selected'));
                
                // Determine which section is on top based on rotation
                // The menu starts at -45deg rotation, placing Section 1 (Classes) at top
                // Each click rotates by 90deg, so:
                // -45deg â†’ Section 1 (Classes) - index 0
                // 45deg â†’ Section 4 (swapped) - index 1
                // 135deg â†’ Section 3 - index 2
                // 225deg â†’ Calendar (swapped) - index 3
                
                // Normalize rotation to handle negative values
                const normalizedRotation = ((currentRotation % 360) + 360) % 360;
                
                // Calculate section index: (rotation + 45) / 90, then mod 4
                let sectionIndex;
                if (currentRotation === -45 || (normalizedRotation >= 315 && normalizedRotation < 360)) {
                    sectionIndex = 0; // Classes
                } else {
                    // For other rotations, calculate directly
                    const adjustedRotation = (currentRotation + 45 + 360) % 360;
                    sectionIndex = Math.floor(adjustedRotation / 90) % 4;
                }
                
                let selectedSection;
                let selectedData;
                
                // Map section index to actual sections
                // Note: Calendar and Section 4 are swapped in rotation order
                if (sectionIndex === 0) {
                    // Section 1 (Classes)
                    selectedSection = classesSectionGroup;
                    selectedData = sectionData.classes;
                } else if (sectionIndex === 1) {
                    // Section 4 (swapped with Calendar at this position)
                    selectedSection = section4Group;
                    selectedData = sectionData.section4;
                } else if (sectionIndex === 2) {
                    // Section 3
                    selectedSection = section3Group;
                    selectedData = sectionData.section3;
                } else if (sectionIndex === 3) {
                    // Calendar (swapped with Section 4 at this position)
                    selectedSection = calendarSectionGroup;
                    selectedData = sectionData.calendar;
                } else {
                    // Fallback to Classes
                    selectedSection = classesSectionGroup;
                    selectedData = sectionData.classes;
                }
                
                if (selectedSection) {
                    selectedSection.classList.add('pie-selected');
                }
                
                // Update top section info display
                const topSectionInfo = document.getElementById('topSectionInfo');
                const topSectionTitle = document.getElementById('topSectionTitle');
                const topSectionEmoji = document.getElementById('topSectionEmoji');
                const topSectionDescription = document.getElementById('topSectionDescription');
                const topSectionButton = document.getElementById('topSectionButton');
                
                if (topSectionInfo && topSectionTitle && topSectionEmoji && topSectionDescription && selectedData) {
                    topSectionTitle.textContent = selectedData.title;
                    topSectionEmoji.textContent = selectedData.emoji;
                    topSectionDescription.textContent = selectedData.description;
                    topSectionInfo.style.display = 'flex';
                    
                    // Add click handler for button
                    if (selectedData.title === 'Classes') {
                        topSectionButton.onclick = () => showClasses();
                    } else if (selectedData.title === 'Calendar') {
                        topSectionButton.onclick = () => alert('Calendar feature coming soon!');
                    } else {
                        topSectionButton.onclick = () => alert(`${selectedData.title} - Coming soon!`);
                    }
                }
            };
            
            // Get section references
            const classesSectionGroup = document.getElementById('classesSectionGroup');
            const calendarSectionGroup = document.getElementById('calendarSectionGroup');
            const section3Group = document.getElementById('section3Group');
            const section4Group = document.getElementById('section4Group');
            
            // Update selected section initially
            updateSelectedSection();
            
            // Section click handlers - removed (no longer clickable)
            
            backBtn.addEventListener('click', () => {
                splitView.classList.remove('active');
                showMainMenu();
                // Hide header buttons when going back to menu
                const headerButtons = document.querySelector('.header-buttons');
                if (headerButtons) {
                    const buttonsToHide = headerButtons.querySelectorAll('.header-btn');
                    buttonsToHide.forEach(btn => {
                        if (btn.id !== 'settingsBtn') {
                            btn.style.display = 'none';
                        }
                    });
                }
            });
            // Notes management
            saveNotesBtn.addEventListener('click', saveCurrentCourseNotes);
            clearNotesBtn.addEventListener('click', clearCurrentCourseNotes);
            const updateNotesBtn = document.getElementById('updateNotesBtn');
            if (updateNotesBtn) {
                updateNotesBtn.addEventListener('click', updateNotesFromFiles);
            }
            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent body scrolling
            });
            closeSettings.addEventListener('click', () => {
                settingsPanel.classList.remove('active');
                document.body.style.overflow = ''; // Restore body scrolling
            });
            
            // Settings
            animationsToggle.addEventListener('click', () => {
                settings.animations = !settings.animations;
                animationsToggle.classList.toggle('active');
                saveSettings();
            });
            
            // OS Background color picker
            if (backgroundColorPicker) {
                backgroundColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    settings.backgroundColor = color;
                    settings.backgroundImage = null; // Clear image when selecting color
                    settings.backgroundGradient = null; // Clear gradient when selecting color
                    if (backgroundColorDisplay) backgroundColorDisplay.style.background = color;
                    const gradientDisplay = document.getElementById('backgroundGradientDisplay');
                    if (gradientDisplay) {
                        gradientDisplay.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                        const label = gradientDisplay.querySelector('div');
                        if (label) label.style.display = 'block';
                    }
                    applyBackground();
                saveSettings();
            });
            }
            
            // Background image upload
            const backgroundImageInput = document.getElementById('backgroundImageInput');
            const backgroundImageUpload = document.getElementById('backgroundImageUpload');
            backgroundImageUpload.addEventListener('click', () => backgroundImageInput.click());
            backgroundImageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        settings.backgroundImage = event.target.result;
                        settings.backgroundColor = null; // Clear color when selecting image
                        settings.backgroundGradient = null; // Clear gradient when selecting image
                        const gradientDisplay = document.getElementById('backgroundGradientDisplay');
                        if (gradientDisplay) {
                            gradientDisplay.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                            const label = gradientDisplay.querySelector('div');
                            if (label) label.style.display = 'block';
                        }
                        applyBackground();
                        updateColorPickerSelection();
                        saveSettings();
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Gradient background display and circles
            const backgroundGradientDisplay = document.getElementById('backgroundGradientDisplay');
            const gradientCircles = document.querySelectorAll('.gradient-circle');
            
            // Function to apply gradient
            function applyGradient(gradient) {
                settings.backgroundGradient = gradient;
                settings.backgroundColor = null; // Clear solid color
                settings.backgroundImage = null; // Clear image
                
                // Update display box
                if (backgroundGradientDisplay) {
                    backgroundGradientDisplay.style.background = gradient;
                    const label = backgroundGradientDisplay.querySelector('div');
                    if (label) label.style.display = 'none';
                }
                
                // Update active state on circles
                gradientCircles.forEach(c => c.style.border = '2px solid rgba(255,255,255,0.5)');
                gradientCircles.forEach(circle => {
                    if (circle.getAttribute('data-gradient') === gradient) {
                        circle.style.border = '2px solid #6ca0ff';
                    }
                });
                
                applyBackground();
                saveSettings();
            }
            
            // Click on gradient display box - select first preset or show first circle
            if (backgroundGradientDisplay) {
                backgroundGradientDisplay.addEventListener('click', () => {
                    // Select first preset if none selected, otherwise do nothing (user clicks circles)
                    if (!settings.backgroundGradient) {
                        const firstGradient = gradientCircles[0]?.getAttribute('data-gradient');
                        if (firstGradient) {
                            applyGradient(firstGradient);
                        }
                    }
                });
            }
            
            // Gradient circle presets
            gradientCircles.forEach(circle => {
                circle.addEventListener('click', () => {
                    const gradient = circle.getAttribute('data-gradient');
                    applyGradient(gradient);
                });
            });
            
            // OS Color pickers
            if (vocabColorPicker) {
                vocabColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    settings.vocabColor = color;
                    if (vocabColorDisplay) vocabColorDisplay.style.background = color;
                    applyTextColors();
                    saveSettings();
                });
            }
            
            if (practiceColorPicker) {
                practiceColorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    settings.practiceColor = color;
                    if (practiceColorDisplay) practiceColorDisplay.style.background = color;
                    applyTextColors();
                    saveSettings();
                });
            }
            
            // Style dropdowns
            if (vocabStyle) {
                vocabStyle.addEventListener('change', () => {
                    settings.vocabStyle = vocabStyle.value;
                    applyTextColors();
                    saveSettings();
                });
            }
            
            if (practiceStyle) {
                practiceStyle.addEventListener('change', () => {
                    settings.practiceStyle = practiceStyle.value;
                    applyTextColors();
                    saveSettings();
                });
            }
            
            // Font size slider
            if (fontSizeSlider) {
                fontSizeSlider.addEventListener('input', (e) => {
                    const size = e.target.value;
                    settings.fontSize = parseInt(size);
                    if (fontSizeDisplay) fontSizeDisplay.textContent = `${size}px`;
                    applyFontSize();
                    saveSettings();
                });
            }
            
            // File upload
            generateFromFilesBtn.addEventListener('click', generateNotesFromFiles);
            testExtractionBtn.addEventListener('click', testTextExtraction);
            
            // Resources button
            if (resourcesBtn) {
                resourcesBtn.addEventListener('click', showResourcesPage);
            }
            
            // Quiz Generator button
            if (quizGeneratorBtn) {
                quizGeneratorBtn.addEventListener('click', showQuizGeneratorModal);
            }
            
            // Flashcard button
            if (flashcardBtn) {
                flashcardBtn.addEventListener('click', showFlashcardModal);
            }
            
            // Clear All Data button
            const clearAllDataBtn = document.getElementById('clearAllDataBtn');
            if (clearAllDataBtn) {
                clearAllDataBtn.addEventListener('click', clearAllData);
            }
        }
        
        function clearAllData() {
            const confirmed = confirm(
                'âš ï¸ WARNING: This will permanently delete ALL data including:\n\n' +
                'â€¢ All saved notes\n' +
                'â€¢ All quiz data\n' +
                'â€¢ All resources/photos\n' +
                'â€¢ All settings\n' +
                'â€¢ Your Canvas access token\n\n' +
                'This action CANNOT be undone!\n\n' +
                'Are you absolutely sure you want to continue?'
            );
            
            if (!confirmed) return;
            
            // Double confirmation
            const doubleConfirmed = confirm(
                'Last chance! This will delete EVERYTHING.\n\n' +
                'Type "DELETE" in the next prompt to confirm, or click Cancel.'
            );
            
            if (!doubleConfirmed) return;
            
            try {
                // Clear all localStorage data
                localStorage.clear();
                
                // Clear all global variables
                canvasToken = '';
                currentCourses = [];
                currentCourse = null;
                savedNotes = {};
                selectedFiles = [];
                courseResources = {};
                settings = {
                    animations: true,
                    backgroundColor: '#000000',
                    backgroundImage: null,
                    backgroundGradient: null,
                    vocabColor: '#00008b',
                    vocabStyle: 'color',
                    practiceColor: '#006400',
                    practiceStyle: 'color',
                    fontSize: 16
                };
                lastUsedFiles = [];
                lastGenerationTime = 0;
                window.quizProgress = new Set();
                
                // Clear the UI
                if (courseGrid) courseGrid.innerHTML = '';
                if (notebook) notebook.innerHTML = '';
                if (tokenInput) tokenInput.value = '';
                
                // Show success message and reload
                alert('âœ… All data has been cleared successfully. The page will reload now.');
                window.location.reload();
            } catch (error) {
                console.error('Error clearing data:', error);
                alert('âŒ Error clearing data. Please try again or clear your browser data manually.');
            }
        }
        
        // Save quiz data to localStorage
        function saveQuizData(courseId, quizData) {
            try {
                const key = `quiz_${courseId}`;
                localStorage.setItem(key, JSON.stringify({
                    ...quizData,
                    savedAt: new Date().toISOString()
                }));
            } catch (error) {
                console.error('Error saving quiz data:', error);
            }
        }
        
        // Load quiz data from localStorage
        function loadQuizData(courseId) {
            try {
                const key = `quiz_${courseId}`;
                const saved = localStorage.getItem(key);
                return saved ? JSON.parse(saved) : null;
            } catch (error) {
                console.error('Error loading quiz data:', error);
                return null;
            }
        }
        
        // Clear quiz data from localStorage
        function clearQuizData(courseId) {
            try {
                const key = `quiz_${courseId}`;
                localStorage.removeItem(key);
            } catch (error) {
                console.error('Error clearing quiz data:', error);
            }
        }
        
        function showQuizGeneratorModal() {
            if (!currentCourse) return;
            
            // Get units/topics from saved notes or current course
            const courseId = String(currentCourse.id);
            const notes = savedNotes[courseId];
            const plan = notes?.units || [];
            
            if (plan.length === 0) {
                alert('No notes found for this course. Please generate notes first.');
                return;
            }
            
            // Check if there's a saved quiz for this course
            const savedQuiz = loadQuizData(courseId);
            const hasSavedQuiz = savedQuiz && savedQuiz.questions && savedQuiz.questions.length > 0;
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease-out;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: rgba(30, 30, 30, 0.95);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 20px;
                    padding: 2rem;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h2 style="margin: 0; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">ðŸ¤– Generate Quiz</h2>
                        <button id="closeQuizModal" style="
                            background: none;
                            border: none;
                            color: #fff;
                            font-size: 28px;
                            cursor: pointer;
                            padding: 0;
                            width: 32px;
                            height: 32px;
                            line-height: 1;
                            transition: transform 0.3s ease;
                        ">Ã—</button>
                    </div>
                    
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Select Quiz Scope:</label>
                        <select id="quizScope" style="
                            width: 100%;
                            padding: 0.8rem;
                            border-radius: 10px;
                            background: rgba(255, 255, 255, 0.1);
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            color: #fff;
                            font-size: 1rem;
                        ">
                            <option value="all">All Topics</option>
                        </select>
                    </div>
                    
                    ${hasSavedQuiz ? `
                    <button id="continueQuizBtn" style="
                        width: 100%;
                        padding: 1rem;
                        margin-bottom: 1rem;
                        border-radius: 10px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        border: none;
                        color: #fff;
                        font-size: 1.1rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.3s ease, box-shadow 0.3s ease;
                        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                    ">Continue Last Quiz (${savedQuiz.completedQuestions || 0}/15)</button>
                    ` : ''}
                    
                    <button id="generateQuizBtn" style="
                        width: 100%;
                        padding: 1rem;
                        border-radius: 10px;
                        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                        border: none;
                        color: #fff;
                        font-size: 1.1rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.3s ease, box-shadow 0.3s ease;
                        box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
                    ">Generate New Quiz</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Populate scope dropdown with units
            const scopeSelect = modal.querySelector('#quizScope');
            scopeSelect.innerHTML = '<option value="all">All Topics</option>';
            plan.forEach(unit => {
                scopeSelect.innerHTML += `<option value="unit-${unit.number}">Unit ${unit.number}: ${unit.title}</option>`;
                unit.topics.forEach(topic => {
                    const optionValue = `topic-${unit.number}-${topic.number}`;
                    console.log('Creating quiz option:', { unit: unit.number, topic: topic.number, value: optionValue });
                    scopeSelect.innerHTML += `<option value="${optionValue}">${unit.number}.${topic.number}: ${topic.title}</option>`;
                });
            });
            
            // Close modal handlers
            const closeModal = () => {
                modal.style.animation = 'fadeIn 0.3s ease-out reverse';
                setTimeout(() => modal.remove(), 300);
            };
            
            modal.querySelector('#closeQuizModal').addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
            
            // Continue quiz handler
            if (hasSavedQuiz) {
                modal.querySelector('#continueQuizBtn').addEventListener('click', () => {
                    closeModal();
                    restoreQuiz(courseId, savedQuiz);
                });
            }
            
            // Generate quiz handler
            modal.querySelector('#generateQuizBtn').addEventListener('click', async () => {
                const scope = scopeSelect.value;
                closeModal();
                // Clear old quiz data when generating new quiz
                clearQuizData(courseId);
                await generateQuiz(scope);
            });
        }
        
        // Save flashcard data to localStorage
        function saveFlashcardData(courseId, flashcardData) {
            try {
                const key = `flashcards_${courseId}`;
                localStorage.setItem(key, JSON.stringify({
                    ...flashcardData,
                    savedAt: new Date().toISOString()
                }));
            } catch (error) {
                console.error('Error saving flashcard data:', error);
            }
        }
        
        // Load flashcard data from localStorage
        function loadFlashcardData(courseId) {
            try {
                const key = `flashcards_${courseId}`;
                const saved = localStorage.getItem(key);
                return saved ? JSON.parse(saved) : null;
            } catch (error) {
                console.error('Error loading flashcard data:', error);
                return null;
            }
        }
        
        // Clear flashcard data from localStorage
        function clearFlashcardData(courseId) {
            try {
                const key = `flashcards_${courseId}`;
                localStorage.removeItem(key);
            } catch (error) {
                console.error('Error clearing flashcard data:', error);
            }
        }
        
        function showFlashcardModal() {
            if (!currentCourse) return;
            
            // Get units/topics from saved notes or current course
            const courseId = String(currentCourse.id);
            const notes = savedNotes[courseId];
            const plan = notes?.units || [];
            
            if (plan.length === 0) {
                alert('No notes found for this course. Please generate notes first.');
                return;
            }
            
            // Check if there's a saved flashcard set for this course
            const savedFlashcards = loadFlashcardData(courseId);
            const hasSavedFlashcards = savedFlashcards && savedFlashcards.flashcards && savedFlashcards.flashcards.length > 0;
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease-out;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: rgba(30, 30, 30, 0.95);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 20px;
                    padding: 2rem;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h2 style="margin: 0; background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">ðŸƒ Flashcards</h2>
                        <button id="closeFlashcardModal" style="
                            background: none;
                            border: none;
                            color: #fff;
                            font-size: 28px;
                            cursor: pointer;
                            padding: 0;
                            width: 32px;
                            height: 32px;
                            line-height: 1;
                            transition: transform 0.3s ease;
                        ">Ã—</button>
                    </div>
                    
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Select Topics:</label>
                        <select id="flashcardScope" style="
                            width: 100%;
                            padding: 0.8rem;
                            border-radius: 10px;
                            background: rgba(255, 255, 255, 0.1);
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            color: #fff;
                            font-size: 1rem;
                        ">
                            <option value="all">All Topics</option>
                        </select>
                    </div>
                    
                    ${hasSavedFlashcards ? `
                    <button id="continueFlashcardsBtn" style="
                        width: 100%;
                        padding: 1rem;
                        margin-bottom: 1rem;
                        border-radius: 10px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        border: none;
                        color: #fff;
                        font-size: 1.1rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.3s ease, box-shadow 0.3s ease;
                        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                    ">Continue Last Set (${savedFlashcards.currentIndex || 0}/${savedFlashcards.flashcards?.length || 0})</button>
                    ` : ''}
                    
                    <button id="startFlashcardsBtn" style="
                        width: 100%;
                        padding: 1rem;
                        border-radius: 10px;
                        background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
                        border: none;
                        color: #fff;
                        font-size: 1.1rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.3s ease, box-shadow 0.3s ease;
                        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                    ">Generate New Flashcards</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Populate scope dropdown with units
            const scopeSelect = modal.querySelector('#flashcardScope');
            scopeSelect.innerHTML = '<option value="all">All Topics</option>';
            plan.forEach(unit => {
                scopeSelect.innerHTML += `<option value="unit-${unit.number}">Unit ${unit.number}: ${unit.title}</option>`;
                unit.topics.forEach(topic => {
                    const optionValue = `topic-${unit.number}-${topic.number}`;
                    scopeSelect.innerHTML += `<option value="${optionValue}">${unit.number}.${topic.number}: ${topic.title}</option>`;
                });
            });
            
            // Close modal handlers
            const closeModal = () => {
                modal.style.animation = 'fadeIn 0.3s ease-out reverse';
                setTimeout(() => modal.remove(), 300);
            };
            
            modal.querySelector('#closeFlashcardModal').addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
            
            // Continue flashcards handler
            if (hasSavedFlashcards) {
                modal.querySelector('#continueFlashcardsBtn').addEventListener('click', () => {
                    closeModal();
                    restoreFlashcards(courseId, savedFlashcards);
                });
            }
            
            // Start flashcards handler
            modal.querySelector('#startFlashcardsBtn').addEventListener('click', () => {
                const scope = scopeSelect.value;
                closeModal();
                // Clear old flashcard data when generating new set
                clearFlashcardData(courseId);
                showFlashcards(scope);
            });
        }
        
        async function extractFlashcardsFromNotes(scope, loadingDiv = null) {
            if (!currentCourse) return [];
            
            const courseId = String(currentCourse.id);
            const notes = savedNotes[courseId];
            if (!notes) return [];
            
            // Helper to clean vocab term - remove file references and other artifacts
            // Only removes file reference patterns, not the actual term content
            function cleanVocabTerm(term) {
                if (!term) return '';
                
                const originalTerm = term;
                
                // Remove file reference patterns in brackets (but keep the term itself)
                // Pattern: "Term [Based on Topic###.pptx]" -> "Term"
                term = term.replace(/\s*\[Based on [^\]]+\]/gi, '');
                term = term.replace(/\s*\[From [^\]]+\]/gi, '');
                term = term.replace(/\s*\[See [^\]]+\]/gi, '');
                term = term.replace(/\s*\[Topic[^\]]+\]/gi, '');
                term = term.replace(/\s*\[.*?\.(pdf|pptx|docx|doc|txt|rtf)\]/gi, '');
                
                // Remove file references in parentheses
                term = term.replace(/\s*\(Based on [^)]+\)/gi, '');
                term = term.replace(/\s*\(From [^)]+\)/gi, '');
                term = term.replace(/\s*\(See [^)]+\)/gi, '');
                term = term.replace(/\s*\(Topic[^)]+\)/gi, '');
                
                // Remove standalone Topic references (but not if it's part of the actual term)
                // Only remove if it's at the start/end with numbers
                term = term.replace(/^Topic\s*\d+[\.\d]*\s+/gi, '');
                term = term.replace(/\s+Topic\s*\d+[\.\d]*$/gi, '');
                
                // Clean up extra spaces and trim
                term = term.trim().replace(/\s+/g, ' ');
                
                // If the term became empty or is too short after cleaning, return empty
                if (!term || term.length < 2) {
                    return '';
                }
                
                // If after cleaning it's just "Topic" or brackets, return empty
                if (term.match(/^\[?Topic\]?$/i) || term.match(/^\[.*\]$/)) {
                    return '';
                }
                
                return term;
            }
            
            // Helper to extract vocab terms from raw text (using {VOCAB} markers)
            function extractVocabTermsFromRaw(text) {
                if (!text) return [];
                const terms = [];
                const foundTerms = new Set();
                
                // Extract {VOCAB}term{VVOCAB} markers
                const vocabPattern = /{VOCAB}([^{]+){VOCAB}/gi;
                let match;
                while ((match = vocabPattern.exec(text)) !== null) {
                    let term = match[1].trim();
                    term = cleanVocabTerm(term);
                    if (term && term.length > 0 && !foundTerms.has(term.toLowerCase())) {
                        foundTerms.add(term.toLowerCase());
                        terms.push(term);
                    }
                }
                
                // Also extract from vocab section (like coloring system does)
                const vocabSectionRegex = /ðŸ§¾\s*Vocabulary\s*\/\s*Terms[\s\S]*?(?=\n\n|ðŸ“|ðŸ”¢|ðŸ’¡|âœ…|$)/i;
                const vocabSectionMatch = text.match(vocabSectionRegex);
                if (vocabSectionMatch) {
                    const vocabSection = vocabSectionMatch[0];
                    // Extract terms that are capitalized words followed by colon or pipe
                    const termPattern = /(^|>|<br>|\n)([A-Z][A-Za-z\s]{1,40})\s*([:|])/gm;
                    let termMatch;
                    while ((termMatch = termPattern.exec(vocabSection)) !== null) {
                        let term = termMatch[2].trim();
                        term = cleanVocabTerm(term);
                        if (term && term.length > 0 && !foundTerms.has(term.toLowerCase())) {
                            foundTerms.add(term.toLowerCase());
                            terms.push(term);
                        }
                    }
                }
                
                return terms;
            }
            
            // Helper to extract vocab terms from HTML content (using .vocab-word spans)
            function extractVocabTermsFromHTML(htmlContent) {
                if (!htmlContent) return [];
                const terms = [];
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                const vocabSpans = tempDiv.querySelectorAll('.vocab-word');
                const foundTerms = new Set();
                
                vocabSpans.forEach(span => {
                    let term = span.textContent.trim();
                    term = cleanVocabTerm(term);
                    if (term && term.length > 0 && !foundTerms.has(term.toLowerCase())) {
                        foundTerms.add(term.toLowerCase());
                        terms.push(term);
                    }
                });
                
                return terms;
            }
            
            // Helper to get raw text from HTML (for context and VOCAB marker extraction)
            function getRawTextFromHTML(htmlContent) {
                if (!htmlContent) return '';
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                return tempDiv.textContent || '';
            }
            
            // Helper to get context text from HTML
            function getContextFromHTML(htmlContent) {
                if (!htmlContent) return '';
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                return tempDiv.textContent || '';
            }
            
            // Collect all vocab terms from selected topics ONLY
            const allTerms = [];
            let contextContent = '';
            
            // Get selected topics based on scope
            const selectedTopics = [];
            
            if (scope === 'all') {
                // All topics - get all topic numbers from topicPages
                if (notes.topicPages) {
                    Object.keys(notes.topicPages).forEach(topicNumber => {
                        selectedTopics.push(topicNumber);
                    });
                }
            } else if (scope.startsWith('unit-')) {
                // Specific unit - get topics that start with unit number
                const unitNum = scope.replace('unit-', '');
                if (notes.topicPages) {
                    Object.keys(notes.topicPages).forEach(topicNumber => {
                        if (topicNumber.startsWith(unitNum + '.')) {
                            selectedTopics.push(topicNumber);
                        }
                    });
                }
            } else if (scope.startsWith('topic-')) {
                // Specific topic - parse like quiz generator does
                // Format: "topic-1-1.1" -> "1.1", "topic-1-1.5" -> "1.5", "topic-2-3.2" -> "3.2"
                const parts = scope.split('-');
                if (parts.length >= 3) {
                    // Join all parts after 'topic' and unit number with dots
                    const topicNum = parts.slice(2).join('.');
                    console.log(`ðŸ” Parsing topic scope: "${scope}" -> topic number: "${topicNum}"`);
                    console.log(`ðŸ” Available topicPages keys:`, notes.topicPages ? Object.keys(notes.topicPages) : 'none');
                    
                    if (notes.topicPages && notes.topicPages[topicNum]) {
                        selectedTopics.push(topicNum);
                        console.log(`âœ… Found exact match: ${topicNum}`);
                    } else {
                        console.warn(`âŒ No matching topic found for scope: ${scope}, topicNum: ${topicNum}`);
                        console.warn(`   Available keys don't include: ${topicNum}`);
                    }
                }
            }
            
            console.log(`ðŸ“‹ Selected topics for flashcards: ${selectedTopics.length} topics`, selectedTopics);
            
            // Extract from ONLY the selected topics
            if (notes.topicPages && selectedTopics.length > 0) {
                selectedTopics.forEach(topicNumber => {
                    const htmlContent = notes.topicPages[topicNumber];
                    if (htmlContent) {
                        // Try extracting from HTML spans first
                        const termsFromHTML = extractVocabTermsFromHTML(htmlContent);
                        console.log(`ðŸ“ Topic ${topicNumber}: Found ${termsFromHTML.length} terms from HTML spans`, termsFromHTML.slice(0, 5));
                        allTerms.push(...termsFromHTML);
                        
                        // Also try extracting from raw text representation
                        const rawText = getRawTextFromHTML(htmlContent);
                        const termsFromRaw = extractVocabTermsFromRaw(rawText);
                        console.log(`ðŸ“ Topic ${topicNumber}: Found ${termsFromRaw.length} terms from raw text`, termsFromRaw.slice(0, 5));
                        allTerms.push(...termsFromRaw);
                        
                        contextContent += getContextFromHTML(htmlContent) + '\n\n';
                    }
                });
            }
            
            console.log(`ðŸ“š Total terms extracted before cleaning: ${allTerms.length}`);
            
            // Only use raw content if we have selected topics and need to extract from it
            // But actually, we should NOT use raw content as it contains all topics
            // Only use the selected topic pages' content
            
            // Remove duplicates and filter out empty/invalid terms
            const uniqueTerms = [...new Set(allTerms.map(t => t.toLowerCase()))].map(t => {
                return allTerms.find(term => term.toLowerCase() === t);
            }).filter(t => {
                if (!t || t.length < 2) return false;
                // Filter out terms that are just brackets, Topic references, or file names
                const cleaned = cleanVocabTerm(t);
                if (!cleaned || cleaned.length < 2) return false;
                if (cleaned.match(/^\[?Topic\]?$/i)) return false;
                if (cleaned.match(/^\[.*\]$/)) return false;
                return true;
            }).map(t => cleanVocabTerm(t)).filter(t => t && t.length > 0);
            
            console.log(`ðŸ“š Found ${uniqueTerms.length} unique vocab terms`);
            
            if (uniqueTerms.length === 0) {
                return [];
            }
            
            // Generate definitions using AI with retry logic (same as notes generation)
            const flashcards = [];
            const BATCH_SIZE = 4; // Process 4 at a time with delays
            const BATCH_DELAY = 100; // 100ms delay between batches
            
            // Helper function to generate definition using retryWithBackoff
            async function generateDefinition(term, context) {
                try {
                    const prompt = `Based on the following study notes content, provide a concise definition (1-2 sentences max) for the term "${term}". Only return the definition, nothing else.

STUDY NOTES CONTENT:
${context.substring(0, 5000)}

TERM: ${term}

Definition:`;
                    
                    const definition = await retryWithBackoff(async () => {
                        const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
                        const aiResponse = await fetch(`${workerApiBase}/api/ai-request`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt: prompt })
                        });
                        
                        if (!aiResponse.ok) {
                            const errorText = await aiResponse.text();
                            throw new Error(`Flashcard Generation Error: ${aiResponse.status} - ${errorText}`);
                        }
                        
                        const aiData = await aiResponse.json();
                        if (aiData.queued) {
                            // Wait for queue and retry
                            const waitTime = aiData.waitTime || aiData.estimatedWait || 5000;
                            console.log(`Flashcard request queued for "${term}", waiting ${Math.ceil(waitTime / 1000)}s...`);
                            await new Promise(resolve => setTimeout(resolve, Math.min(waitTime, 10000)));
                            // Retry the request
                            throw new Error('QUEUED_RETRY'); // Special error to trigger retry
                        }
                        
                        return aiData?.result || '';
                    }, 5, 2000); // 5 retries with 2s base delay
                    
                    if (!definition) return null;
                    
                    let cleanedDefinition = definition.trim();
                    cleanedDefinition = cleanedDefinition.replace(/^(?:Definition:?\s*|"|')/i, '').replace(/["']$/g, '').trim();
                    
                    if (cleanedDefinition && cleanedDefinition.length > 0) {
                        return { term, definition: cleanedDefinition };
                    }
                    return null;
                } catch (error) {
                    console.error(`Error generating definition for ${term}:`, error);
                    return null;
                }
            }
            
            // Process terms in batches (like notes generation)
            for (let i = 0; i < uniqueTerms.length; i += BATCH_SIZE) {
                const batch = uniqueTerms.slice(i, i + BATCH_SIZE);
                
                // Process batch in parallel (queue worker handles rate limiting)
                const batchPromises = batch.map(term => generateDefinition(term, contextContent));
                const results = await Promise.allSettled(batchPromises);
                
                results.forEach((result) => {
                    if (result.status === 'fulfilled' && result.value) {
                        flashcards.push(result.value);
                    }
                });
                
                // Update loading message
                if (loadingDiv && loadingDiv.parentNode) {
                    const progressText = loadingDiv.querySelector('p:last-child');
                    if (progressText) {
                        progressText.textContent = `Extracting terms and generating definitions (${Math.min(i + BATCH_SIZE, uniqueTerms.length)}/${uniqueTerms.length} terms processed, ${flashcards.length} flashcards created)`;
                    }
                }
                
                // Delay between batches
                if (i + BATCH_SIZE < uniqueTerms.length) {
                    await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
                }
            }
            
            return flashcards;
        }
        
        async function showFlashcards(scope) {
            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 10001;
                background: rgba(0, 0, 0, 0.9);
                padding: 2rem;
                border-radius: 20px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                color: #fff;
                text-align: center;
            `;
            loadingDiv.innerHTML = `
                <div class="loading-wave">
                    <div class="loading-wave-bar"></div>
                    <div class="loading-wave-bar"></div>
                    <div class="loading-wave-bar"></div>
                    <div class="loading-wave-bar"></div>
                    <div class="loading-wave-bar"></div>
                </div>
                <p style="margin-top: 2rem; color: #6ca0ff; font-size: 1.1rem; font-weight: 600;">Generating flashcards...</p>
                <p style="margin-top: 1rem; color: #aaa; font-size: 0.9rem;">Extracting terms and generating definitions</p>
            `;
            document.body.appendChild(loadingDiv);
            
            try {
                const flashcards = await extractFlashcardsFromNotes(scope, loadingDiv);
                
                loadingDiv.remove();
                
                if (flashcards.length === 0) {
                    alert('No flashcards could be generated. No vocabulary terms were found in the selected topics.');
                    return;
                }
                
                // Display flashcards with the new improved UI
                displayFlashcards(flashcards, 0, scope);
            } catch (error) {
                loadingDiv.remove();
                console.error('Error generating flashcards:', error);
                alert('Error generating flashcards: ' + error.message);
            }
        }
        
        function restoreFlashcards(courseId, savedData) {
            if (!savedData || !savedData.flashcards || savedData.flashcards.length === 0) {
                alert('No saved flashcard data found.');
                return;
            }
            
            displayFlashcards(savedData.flashcards, savedData.currentIndex || 0, savedData.scope);
        }
        
        function displayFlashcards(flashcards, startIndex = 0, scope = 'all') {
            const courseId = String(currentCourse?.id);
            
            // Create flashcard display with enhanced styling
            const flashcardContainer = document.createElement('div');
            flashcardContainer.id = 'flashcardContainer';
            flashcardContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(20, 20, 40, 0.98) 100%);
                backdrop-filter: blur(20px);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 2rem;
                animation: fadeIn 0.3s ease-out;
            `;
            
            document.body.appendChild(flashcardContainer);
            
            let currentIndex = Math.max(0, Math.min(startIndex, flashcards.length - 1));
            let isFlipped = false;
            
            // Save progress function
            const saveProgress = () => {
                if (courseId) {
                    saveFlashcardData(courseId, {
                        flashcards: flashcards,
                        currentIndex: currentIndex,
                        scope: scope
                    });
                }
            };
            
            function renderCard() {
                // Save progress before rendering
                saveProgress();
                
                if (currentIndex >= flashcards.length) {
                    // Clear saved progress when finished
                    if (courseId) {
                        clearFlashcardData(courseId);
                    }
                    
                    flashcardContainer.innerHTML = `
                        <div style="text-align: center; color: #fff; animation: fadeInUp 0.5s ease-out;">
                            <div style="font-size: 4rem; margin-bottom: 1rem; animation: bounce 1s ease-in-out infinite;">ðŸŽ‰</div>
                            <h2 style="margin-bottom: 1rem; background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 2.5rem;">All Done!</h2>
                            <p style="margin-bottom: 2rem; font-size: 1.2rem; opacity: 0.8;">You've reviewed all ${flashcards.length} flashcards</p>
                            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                                <button id="restartFlashcards" style="
                                    padding: 1rem 2rem;
                                    border-radius: 12px;
                                    background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
                                    border: none;
                                    color: #fff;
                                    font-size: 1.1rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
                                ">ðŸ”„ Start Over</button>
                                <button id="closeFlashcards" style="
                                    padding: 1rem 2rem;
                                    border-radius: 12px;
                                    background: rgba(255, 255, 255, 0.1);
                                    border: 1px solid rgba(255, 255, 255, 0.2);
                                    color: #fff;
                                    font-size: 1.1rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                ">âœ• Close</button>
                            </div>
                        </div>
                    `;
                    
                    flashcardContainer.querySelector('#restartFlashcards').addEventListener('click', () => {
                        currentIndex = 0;
                        isFlipped = false;
                        renderCard();
                    });
                    
                    flashcardContainer.querySelector('#restartFlashcards').addEventListener('mouseenter', function() {
                        this.style.transform = 'translateY(-2px) scale(1.05)';
                        this.style.boxShadow = '0 6px 20px rgba(102, 126, 234, 0.6)';
                    });
                    flashcardContainer.querySelector('#restartFlashcards').addEventListener('mouseleave', function() {
                        this.style.transform = 'translateY(0) scale(1)';
                        this.style.boxShadow = '0 4px 15px rgba(102, 126, 234, 0.4)';
                    });
                    
                    flashcardContainer.querySelector('#closeFlashcards').addEventListener('click', () => {
                        flashcardContainer.style.animation = 'fadeOut 0.3s ease-out';
                        setTimeout(() => flashcardContainer.remove(), 300);
                    });
                    return;
                }
                
                const card = flashcards[currentIndex];
                const progressPercent = ((currentIndex + 1) / flashcards.length) * 100;
                
                flashcardContainer.innerHTML = `
                    <style>
                        @keyframes cardSlideIn {
                            from {
                                opacity: 0;
                                transform: translateX(50px) scale(0.9);
                            }
                            to {
                                opacity: 1;
                                transform: translateX(0) scale(1);
                            }
                        }
                        .flashcard-card {
                            animation: cardSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
                        }
                    </style>
                    <div style="text-align: center; margin-bottom: 1.5rem; color: #fff; width: 100%; max-width: 600px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <span style="font-size: 0.9rem; opacity: 0.7;">Card ${currentIndex + 1} of ${flashcards.length}</span>
                            <span style="font-size: 0.9rem; opacity: 0.7;">${Math.round(progressPercent)}%</span>
                        </div>
                        <div style="width: 100%; height: 6px; background: rgba(255, 255, 255, 0.1); border-radius: 10px; overflow: hidden;">
                            <div style="width: ${progressPercent}%; height: 100%; background: linear-gradient(90deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%); transition: width 0.3s ease; border-radius: 10px;"></div>
                        </div>
                    </div>
                    
                    <div id="flashcard" class="flashcard-card" style="
                        width: 90%;
                        max-width: 650px;
                        min-height: 350px;
                        background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
                        border-radius: 24px;
                        padding: 3.5rem;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        cursor: pointer;
                        transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease;
                        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 40px rgba(102, 126, 234, 0.3);
                        color: #fff;
                        font-size: 1.6rem;
                        font-weight: 600;
                        text-align: center;
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1) 0%, transparent 50%); pointer-events: none;"></div>
                        <div id="cardFront" style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; padding: 2rem; box-sizing: border-box; word-wrap: break-word; overflow-wrap: break-word; transition: opacity 0.3s ease, transform 0.3s ease;">${card.term}</div>
                        <div id="cardBack" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; padding: 2rem; box-sizing: border-box; word-wrap: break-word; overflow-wrap: break-word; line-height: 1.6; opacity: 0; transform: scale(0.8); pointer-events: none; transition: opacity 0.3s ease, transform 0.3s ease;">${card.definition}</div>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; margin-top: 2.5rem; flex-wrap: wrap; justify-content: center;">
                        <button id="prevCard" style="
                            padding: 0.9rem 1.8rem;
                            border-radius: 12px;
                            background: rgba(255, 255, 255, 0.1);
                            border: 2px solid rgba(255, 255, 255, 0.2);
                            color: #fff;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            ${currentIndex === 0 ? 'opacity: 0.4; cursor: not-allowed;' : ''}
                        " ${currentIndex === 0 ? 'disabled' : ''}>â† Previous</button>
                        
                        <button id="flipCard" style="
                            padding: 0.9rem 1.8rem;
                            border-radius: 12px;
                            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
                            border: none;
                            color: #fff;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
                        ">ðŸ”„ Flip</button>
                        
                        <button id="nextCard" style="
                            padding: 0.9rem 1.8rem;
                            border-radius: 12px;
                            background: rgba(255, 255, 255, 0.1);
                            border: 2px solid rgba(255, 255, 255, 0.2);
                            color: #fff;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        ">Next â†’</button>
                        
                        <button id="closeFlashcards" style="
                            padding: 0.9rem 1.8rem;
                            border-radius: 12px;
                            background: rgba(255, 0, 0, 0.2);
                            border: 2px solid rgba(255, 0, 0, 0.3);
                            color: #fff;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        ">âœ• Close</button>
                    </div>
                `;
                
                const flashcard = flashcardContainer.querySelector('#flashcard');
                const cardFront = flashcardContainer.querySelector('#cardFront');
                const cardBack = flashcardContainer.querySelector('#cardBack');
                const flipBtn = flashcardContainer.querySelector('#flipCard');
                const prevBtn = flashcardContainer.querySelector('#prevCard');
                const nextBtn = flashcardContainer.querySelector('#nextCard');
                const closeBtn = flashcardContainer.querySelector('#closeFlashcards');
                
                // Add hover effects to card
                flashcard.addEventListener('mouseenter', () => {
                    if (!isFlipped) {
                        flashcard.style.transform = 'translateY(-5px) scale(1.02)';
                        flashcard.style.boxShadow = '0 25px 70px rgba(0, 0, 0, 0.7), 0 0 50px rgba(102, 126, 234, 0.4)';
                    }
                });
                flashcard.addEventListener('mouseleave', () => {
                    if (!isFlipped) {
                        flashcard.style.transform = 'translateY(0) scale(1)';
                        flashcard.style.boxShadow = '0 20px 60px rgba(0, 0, 0, 0.6), 0 0 40px rgba(102, 126, 234, 0.3)';
                    }
                });
                
                // Add hover effects to buttons
                [prevBtn, nextBtn, flipBtn, closeBtn].forEach(btn => {
                    if (btn && !btn.disabled) {
                        btn.addEventListener('mouseenter', function() {
                            this.style.transform = 'translateY(-2px)';
                            this.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
                        });
                        btn.addEventListener('mouseleave', function() {
                            this.style.transform = 'translateY(0)';
                            this.style.boxShadow = 'none';
                        });
                    }
                });
                
                const flipCard = () => {
                    isFlipped = !isFlipped;
                    if (isFlipped) {
                        // Show back, hide front
                        cardFront.style.opacity = '0';
                        cardFront.style.transform = 'scale(0.8)';
                        cardFront.style.pointerEvents = 'none';
                        cardBack.style.opacity = '1';
                        cardBack.style.transform = 'scale(1)';
                        cardBack.style.pointerEvents = 'auto';
                    } else {
                        // Show front, hide back
                        cardFront.style.opacity = '1';
                        cardFront.style.transform = 'scale(1)';
                        cardFront.style.pointerEvents = 'auto';
                        cardBack.style.opacity = '0';
                        cardBack.style.transform = 'scale(0.8)';
                        cardBack.style.pointerEvents = 'none';
                    }
                    saveProgress();
                };
                
                flashcard.addEventListener('click', flipCard);
                flipBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    flipCard();
                });
                
                prevBtn.addEventListener('click', () => {
                    if (currentIndex > 0) {
                        currentIndex--;
                        isFlipped = false;
                        renderCard();
                    }
                });
                
                nextBtn.addEventListener('click', () => {
                    if (currentIndex < flashcards.length - 1) {
                        currentIndex++;
                        isFlipped = false;
                        renderCard();
                    } else {
                        // Automatically go to completion screen
                        currentIndex++;
                        renderCard();
                    }
                });
                
                closeBtn.addEventListener('click', () => {
                    saveProgress();
                    flashcardContainer.style.animation = 'fadeOut 0.3s ease-out';
                    setTimeout(() => flashcardContainer.remove(), 300);
                });
                
                // Keyboard navigation
                const handleKeyPress = (e) => {
                    if (e.key === 'ArrowLeft' && currentIndex > 0) {
                        currentIndex--;
                        isFlipped = false;
                        renderCard();
                    } else if (e.key === 'ArrowRight' && currentIndex < flashcards.length) {
                        currentIndex++;
                        isFlipped = false;
                        renderCard();
                    } else if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        flipCard();
                    } else if (e.key === 'Escape') {
                        saveProgress();
                        flashcardContainer.style.animation = 'fadeOut 0.3s ease-out';
                        setTimeout(() => {
                            flashcardContainer.remove();
                            document.removeEventListener('keydown', handleKeyPress);
                        }, 300);
                    }
                };
                
                document.addEventListener('keydown', handleKeyPress);
                
                // Clean up on close
                const originalClose = closeBtn.onclick;
                closeBtn.onclick = () => {
                    document.removeEventListener('keydown', handleKeyPress);
                    if (originalClose) originalClose();
                };
            }
            
            renderCard();
        }
        
        async function generateQuiz(scope) {
            if (!currentCourse) return;
            
            // Add loading indicator without destroying existing content
            let loadingDiv = document.getElementById('quiz-loading');
            if (!loadingDiv) {
                loadingDiv = document.createElement('div');
                loadingDiv.id = 'quiz-loading';
                loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10001; background: rgba(0,0,0,0.9); padding: 2rem; border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);';
                loadingDiv.innerHTML = `
                    <div class="loading-wave">
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                    </div>
                    <p style="margin-top: 2rem; color: #6ca0ff; font-size: 1.1rem; font-weight: 600;">Generating quiz...</p>
                `;
                document.body.appendChild(loadingDiv);
            }
            
            try {
                // Save courseId at the start
                const courseId = String(currentCourse.id);
                const notes = savedNotes[courseId];
                
                console.log('=== QUIZ GENERATION DEBUG ===');
                console.log('Scope:', scope);
                console.log('Course ID:', courseId);
                console.log('Has notes:', !!notes);
                console.log('Has topicPages:', !!(notes && notes.topicPages));
                console.log('topicPages keys:', notes && notes.topicPages ? Object.keys(notes.topicPages) : 'none');
                console.log('Sample topic key:', notes && notes.topicPages ? Object.keys(notes.topicPages)[0] : 'none');
                
                // Build quiz prompt based on scope
                let quizPrompt = `You are creating a comprehensive quiz based on the following study notes content:\n\n`;
                let extractedContent = '';
                
                // Use saved topicPages as primary source (most reliable)
                if (notes && notes.topicPages && Object.keys(notes.topicPages).length > 0) {
                    console.log('Using topicPages with', Object.keys(notes.topicPages).length, 'entries');
                    if (scope === 'all') {
                        Object.values(notes.topicPages).forEach((htmlContent, idx) => {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = htmlContent;
                            const textContent = tempDiv.textContent?.trim();
                            console.log(`Topic ${idx}: HTML len=${htmlContent.length}, text len=${textContent.length}`);
                            if (textContent && textContent.length > 50) {
                                extractedContent += `\n\n--- STUDY NOTES CONTENT ---\n${textContent}`;
                            }
                        });
                    } else if (scope.startsWith('unit-')) {
                        const unitNum = parseInt(scope.split('-')[1]);
                        console.log('Looking for unit:', unitNum);
                        const unit = notes.units.find(u => u.number === unitNum);
                        console.log('Found unit:', !!unit, 'Topics:', unit?.topics?.length);
                        if (unit) {
                            unit.topics.forEach(topic => {
                                console.log(`Checking topic ${topic.number}, has in topicPages:`, !!(notes.topicPages[topic.number]));
                                if (notes.topicPages[topic.number]) {
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = notes.topicPages[topic.number];
                                    const textContent = tempDiv.textContent?.trim();
                                    if (textContent && textContent.length > 50) {
                                        extractedContent += `\n\n--- ${topic.number}: ${topic.title} ---\n${textContent}`;
                                    }
                                }
                            });
                        }
                    } else if (scope.startsWith('topic-')) {
                        // Parse: "topic-1-1.1" -> "1.1", "topic-1-1.5" -> "1.5", "topic-2-3.2" -> "3.2"
                        const parts = scope.split('-');
                        if (parts.length >= 3) {
                            const topicNum = parts.slice(2).join('.'); // Join all parts after 'topic' and unit number
                            console.log('Looking for topic:', topicNum, 'Has in topicPages:', !!(notes.topicPages[topicNum]));
                            if (notes.topicPages[topicNum]) {
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = notes.topicPages[topicNum];
                                const textContent = tempDiv.textContent?.trim();
                                console.log('Extracted text length:', textContent.length);
                                if (textContent && textContent.length > 50) {
                                    extractedContent += `\n\n${textContent}`;
                                }
                            }
                        }
                    }
                } else {
                    console.log('No topicPages found, trying DOM fallback');
                }
                
                // Limit content to avoid token limits
                if (extractedContent.length > 30000) {
                    extractedContent = extractedContent.substring(0, 30000) + '\n\n[Content truncated for length...]';
                }
                
                console.log('Final extracted content length:', extractedContent.length);
                console.log('First 200 chars:', extractedContent.substring(0, 200));
                
                if (extractedContent.length === 0) {
                    console.error('No content extracted for quiz! Make sure you have generated notes first.');
                } else {
                    console.log(`âœ… Quiz scope: ${scope}, Extracted ${extractedContent.length} chars from notes`);
                }
                
                quizPrompt += extractedContent;
                quizPrompt += `\n\nBased on this study material, generate a QUIZ WITH ONLY MULTIPLE CHOICE QUESTIONS.\n\n`;
                quizPrompt += `FORMAT REQUIREMENTS:\n`;
                quizPrompt += `- Generate exactly 15 multiple choice questions\n`;
                quizPrompt += `- Each question must follow this EXACT format:\n`;
                quizPrompt += `  QUESTION NUMBER. Question text here?\n`;
                quizPrompt += `  A) First option\n`;
                quizPrompt += `  B) Second option\n`;
                quizPrompt += `  C) Third option\n`;
                quizPrompt += `  D) Fourth option\n\n`;
                quizPrompt += `- After all questions, provide an ANSWER KEY section with short explanations:\n`;
                quizPrompt += `  ANSWER KEY:\n`;
                quizPrompt += `  1. A - Brief explanation sentence here.\n`;
                quizPrompt += `  2. B - Brief explanation sentence here.\n`;
                quizPrompt += `  (continue for all questions with one sentence per answer)\n\n`;
                quizPrompt += `- Focus EXCLUSIVELY on testing key concepts, definitions, and important details from the notes provided above\n`;
                quizPrompt += `- Make options plausible but only one should be clearly correct\n`;
                quizPrompt += `- Keep explanations to ONE SENTENCE only\n`;
                quizPrompt += `- Vary difficulty across easy, medium, and challenging questions\n`;
                
                // Call AI through worker with retry logic (same as notes generation)
                const quizContent = await retryWithBackoff(async () => {
                const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
                const response = await fetch(`${workerApiBase}/api/ai-request`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: quizPrompt
                    })
                });
                
                if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Quiz Generation Error: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                if (data.queued) {
                        // Wait for queue and retry
                        const waitTime = data.waitTime || data.estimatedWait || 5000;
                        console.log(`Quiz request queued, position: ${data.position + 1}, waiting ${Math.ceil(waitTime / 1000)}s...`);
                        await new Promise(resolve => setTimeout(resolve, Math.min(waitTime, 10000)));
                        // Retry the request
                        throw new Error('QUEUED_RETRY'); // Special error to trigger retry
                    }
                    
                    return data?.result || '';
                }, 5, 2000); // 5 retries with 2s base delay
                
                // Display quiz - hide all existing pages first
                const pages = document.querySelectorAll('.topic-page');
                pages.forEach(p => p.classList.remove('active'));
                
                // Check if quiz page already exists
                let quizPage = document.getElementById('page-quiz');
                if (!quizPage) {
                    quizPage = document.createElement('div');
                    quizPage.className = 'topic-page active';
                    quizPage.id = 'page-quiz';
                    
                    // Ensure notebook container exists
                    if (!document.getElementById('notebookContent')) {
                        notebook.innerHTML = `
                            <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                            <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                        `;
                    }
                    
                    const notebookContent = document.getElementById('notebookContent');
                    notebookContent.appendChild(quizPage);
                } else {
                    quizPage.classList.add('active');
                }
                
                // Format quiz content and get quiz data
                const formatted = formatQuizContent(quizContent);
                quizPage.innerHTML = `
                    <div class="topic-page-content">
                        <h2>ðŸ“ Generated Quiz</h2>
                        ${formatted.html}
                    </div>
                `;
                
                // Reset quiz progress for new quiz
                window.quizProgress = new Set();
                
                                    // Save quiz data to localStorage (courseId already defined above)
                saveQuizData(courseId, {
                    ...formatted.quizData,
                    scope: scope,
                    rawContent: quizContent,
                    completedQuestionNumbers: Array.from(window.quizProgress) // Save which questions are completed
                });
                
                // Remove loading indicator
                const loadingDiv = document.getElementById('quiz-loading');
                if (loadingDiv) loadingDiv.remove();
                
            } catch (error) {
                console.error('Error generating quiz:', error);
                // Remove loading indicator on error too
                const loadingDiv = document.getElementById('quiz-loading');
                if (loadingDiv) loadingDiv.remove();
                alert('Error generating quiz. Please try again.');
            }
        }
        
        function formatQuizContent(content, savedProgress = null) {
            // Parse and format interactive quiz content
            const lines = content.split('\n');
            let formatted = '';
            let inAnswerKey = false;
            let questionNumber = 0;
            const questions = [];
            const answerKey = {};
            const explanations = {};
            
            // First pass: extract questions, answers, and explanations
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.toLowerCase().includes('answer key')) {
                    inAnswerKey = true;
                    continue;
                }
                
                if (inAnswerKey && /^\d+\.\s+[A-D]\s*-\s*/.test(line)) {
                    const match = line.match(/^(\d+)\.\s+([A-D])\s*-\s*(.+)$/);
                    if (match) {
                        const qNum = match[1];
                        answerKey[qNum] = match[2];
                        explanations[qNum] = match[3];
                    }
                } else if (!inAnswerKey && /^\d+\.\s+/.test(line)) {
                    questionNumber++;
                    questions.push({ number: questionNumber, text: line, options: [] });
                } else if (!inAnswerKey && /^[A-D]\)\s+/.test(line)) {
                    if (questions.length > 0) {
                        questions[questions.length - 1].options.push(line);
                    }
                }
            }
            
            // Second pass: render interactive quiz with saved progress
            questions.forEach(q => {
                const qNum = String(q.number);
                const explanation = explanations[qNum] || '';
                const isCompleted = savedProgress && savedProgress.has(parseInt(qNum));
                const correctAnswer = answerKey[qNum];
                
                formatted += `<div class="quiz-question-wrapper" data-question="${qNum}" data-correct="${correctAnswer}">`;
                formatted += `<div class="quiz-question"><strong>${q.text}</strong></div>`;
                q.options.forEach(opt => {
                    const letter = opt.substring(0, 1);
                    const escapedExplanation = explanation.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                    const isCorrect = letter === correctAnswer;
                    const isSelected = isCompleted && isCorrect ? 'quiz-correct' : '';
                    formatted += `<div class="quiz-option ${isSelected}" data-option="${letter}" onclick="handleQuizClick(${qNum}, '${letter}', '${correctAnswer}', '${escapedExplanation}')">${opt}</div>`;
                });
                if (isCompleted) {
                    formatted += `<div class="quiz-explanation" id="explanation-${qNum}" style="display:block;">âœ“ Correct${explanation ? ` - ${explanation}` : ''}</div>`;
                } else {
                    formatted += `<div class="quiz-explanation" id="explanation-${qNum}" style="display:none;"></div>`;
                }
                formatted += '</div>';
            });
            
            // Return both formatted HTML and quiz data structure
            return {
                html: formatted,
                quizData: {
                    questions: questions.map(q => ({
                        number: q.number,
                        text: q.text,
                        options: q.options
                    })),
                    answerKey: answerKey,
                    explanations: explanations,
                    completedQuestions: savedProgress ? savedProgress.size : 0
                }
            };
        }
        
        // Make handleQuizClick globally available
        window.handleQuizClick = function(questionNum, selectedOption, correctAnswer, explanation) {
            const explanationDiv = document.getElementById(`explanation-${questionNum}`);
            const questionWrapper = document.querySelector(`[data-question="${questionNum}"]`);
            const allOptions = questionWrapper.querySelectorAll('.quiz-option');
            const selectedElement = questionWrapper.querySelector(`[data-option="${selectedOption}"]`);
            
            if (selectedOption === correctAnswer) {
                // Correct answer
                allOptions.forEach(opt => opt.classList.remove('quiz-wrong'));
                selectedElement.classList.add('quiz-correct');
                explanationDiv.style.display = 'block';
                explanationDiv.innerHTML = 'âœ“ Correct' + (explanation ? ` - ${explanation}` : '');
                
                // Mark this question as completed
                window.quizProgress = window.quizProgress || new Set();
                window.quizProgress.add(parseInt(questionNum));
                
                // Save progress to localStorage
                if (currentCourse) {
                    const currentCourseId = String(currentCourse.id);
                    const savedQuiz = loadQuizData(currentCourseId);
                    if (savedQuiz) {
                        saveQuizData(currentCourseId, {
                            ...savedQuiz,
                            completedQuestions: window.quizProgress.size,
                            completedQuestionNumbers: Array.from(window.quizProgress) // Save which questions are completed
                        });
                    }
                }
            } else {
                // Wrong answer
                selectedElement.classList.add('quiz-wrong');
                setTimeout(() => {
                    selectedElement.classList.remove('quiz-wrong');
                }, 1000);
            }
        };
        
        // Restore saved quiz
        function restoreQuiz(courseId, savedQuiz) {
            if (!currentCourse || !savedQuiz) return;
            
            // Display quiz - hide all existing pages first
            const pages = document.querySelectorAll('.topic-page');
            pages.forEach(p => p.classList.remove('active'));
            
            // Check if quiz page already exists
            let quizPage = document.getElementById('page-quiz');
            if (!quizPage) {
                quizPage = document.createElement('div');
                quizPage.className = 'topic-page active';
                quizPage.id = 'page-quiz';
                
                // Ensure notebook container exists
                if (!document.getElementById('notebookContent')) {
                    notebook.innerHTML = `
                        <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                        <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                    `;
                }
                
                const notebookContent = document.getElementById('notebookContent');
                notebookContent.appendChild(quizPage);
            } else {
                quizPage.classList.add('active');
            }
            
            // Restore progress
            window.quizProgress = new Set();
            if (savedQuiz.completedQuestionNumbers && savedQuiz.completedQuestionNumbers.length > 0) {
                // Restore which specific questions were completed
                savedQuiz.completedQuestionNumbers.forEach(qNum => {
                    window.quizProgress.add(qNum);
                });
            }
            
            // Restore quiz using saved raw content or reconstruct from saved data
            let quizContent = savedQuiz.rawContent;
            if (!quizContent && savedQuiz.questions) {
                // Reconstruct quiz content from saved data if raw content is missing
                quizContent = '';
                savedQuiz.questions.forEach(q => {
                    quizContent += `${q.number}. ${q.text}\n`;
                    q.options.forEach(opt => {
                        quizContent += `${opt}\n`;
                    });
                    quizContent += '\n';
                });
                if (savedQuiz.answerKey) {
                    quizContent += 'ANSWER KEY:\n';
                    Object.keys(savedQuiz.answerKey).forEach(qNum => {
                        const ans = savedQuiz.answerKey[qNum];
                        const exp = savedQuiz.explanations?.[qNum] || '';
                        quizContent += `${qNum}. ${ans} - ${exp}\n`;
                    });
                }
            }
            
            // Format and display quiz with saved progress
            const formatted = formatQuizContent(quizContent || '', window.quizProgress);
            
            quizPage.innerHTML = `
                <div class="topic-page-content">
                    <h2>ðŸ“ Generated Quiz (${savedQuiz.completedQuestions || 0}/15 completed)</h2>
                    ${formatted.html}
                </div>
            `;
        }
        
        function showResourcesPage() {
            if (!currentCourse) return;
            
            const courseId = String(currentCourse.id);
            const resources = courseResources[courseId] || [];
            
            // Hide all existing topic pages first
            const pages = document.querySelectorAll('.topic-page');
            pages.forEach(p => p.classList.remove('active'));
            
            // Check if resources page already exists
            let resourcesPage = document.getElementById('page-resources');
            if (!resourcesPage) {
                resourcesPage = document.createElement('div');
                resourcesPage.className = 'topic-page active';
                resourcesPage.id = 'page-resources';
                
                // Ensure notebook container exists
                if (!document.getElementById('notebookContent')) {
                    notebook.innerHTML = `
                        <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                        <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                    `;
                }
                
                const notebookContent = document.getElementById('notebookContent');
                notebookContent.appendChild(resourcesPage);
            } else {
                resourcesPage.classList.add('active');
            }
            
            // Set content
            resourcesPage.innerHTML = `
                <div class="topic-page-content">
                    <h2>ðŸ“ Course Resources</h2>
                    <div style="margin: 2rem 0;">
                        <input type="file" id="resourceUploadInput" accept="image/*" multiple style="display: none;">
                        <button class="btn btn-primary" onclick="document.getElementById('resourceUploadInput').click();" style="
                            margin-bottom: 1.5rem;
                            padding: 0.8rem 1.5rem;
                            border-radius: 10px;
                            background: linear-gradient(135deg, var(--accent-color-1) 0%, var(--accent-color-2) 100%);
                            border: none;
                            color: #fff;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.3)'">
                            ðŸ“¸ Upload Photos
                        </button>
                        <div id="resourcesGallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1.5rem; margin-top: 1.5rem;">
                            ${resources.length === 0 ? '<p style="grid-column: 1/-1; text-align: center; color: #888;">No resources uploaded yet. Click "Upload Photos" to add images.</p>' : ''}
                        </div>
                    </div>
                </div>
            `;
            
            // Render existing resources
            renderResourcesGallery(resources);
            
            // Setup upload handler
            const uploadInput = document.getElementById('resourceUploadInput');
            if (uploadInput) {
                uploadInput.addEventListener('change', (e) => handleResourceUpload(e, courseId));
            }
        }
        
        function renderResourcesGallery(resources) {
            const gallery = document.getElementById('resourcesGallery');
            if (!gallery) return;
            
            resources.forEach((resource, index) => {
                const imgDiv = document.createElement('div');
                imgDiv.style.cssText = `
                    position: relative;
                    border-radius: 12px;
                    overflow: hidden;
                    cursor: pointer;
                    transition: transform 0.3s ease;
                    aspect-ratio: 1;
                    background: rgba(255,255,255,0.05);
                `;
                imgDiv.innerHTML = `
                    <img src="${resource.url}" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                    <button onclick="deleteResource(${index})" style="
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: rgba(255,0,0,0.8);
                        border: none;
                        border-radius: 50%;
                        width: 30px;
                        height: 30px;
                        color: white;
                        font-size: 18px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='scale(1.2)'; this.style.background='rgba(255,0,0,1)'" 
                    onmouseout="this.style.transform='scale(1)'; this.style.background='rgba(255,0,0,0.8)'">Ã—</button>
                `;
                gallery.appendChild(imgDiv);
            });
        }
        
        function deleteResource(index) {
            if (!currentCourse) return;
            const courseId = String(currentCourse.id);
            const resources = courseResources[courseId] || [];
            resources.splice(index, 1);
            courseResources[courseId] = resources;
            saveResources();
            showResourcesPage();
        }
        
        function handleResourceUpload(event, courseId) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (!courseResources[courseId]) {
                            courseResources[courseId] = [];
                        }
                        courseResources[courseId].push({
                            url: e.target.result,
                            name: file.name,
                            type: file.type,
                            uploaded: Date.now()
                        });
                        saveResources();
                        showResourcesPage();
                    };
                    reader.readAsDataURL(file);
                }
            });
            // Reset input
            event.target.value = '';
        }
        
        function saveResources() {
            try {
                // Convert resources to storage-friendly format
                const resourcesToSave = {};
                Object.keys(courseResources).forEach(courseId => {
                    resourcesToSave[courseId] = courseResources[courseId];
                });
                localStorage.setItem('courseResources', JSON.stringify(resourcesToSave));
            } catch (error) {
                console.error('Error saving resources:', error);
            }
        }
        
        function loadResources() {
            try {
                const saved = localStorage.getItem('courseResources');
                if (saved) {
                    courseResources = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading resources:', error);
                courseResources = {};
            }
        }

        // Admin tracking configuration
        const ADMIN_API_BASE = 'https://shiny-cell-b460.quintify2.workers.dev'; // Admin worker URL
        
        // Device fingerprinting function
        function getDeviceFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Device fingerprint', 2, 2);
            
            return {
                userAgent: navigator.userAgent,
                language: navigator.language,
                languages: navigator.languages?.join(',') || '',
                platform: navigator.platform,
                screenWidth: screen.width,
                screenHeight: screen.height,
                screenColorDepth: screen.colorDepth,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                canvasFingerprint: canvas.toDataURL().slice(0, 50), // Simplified fingerprint
                hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                maxTouchPoints: navigator.maxTouchPoints || 0,
                cookieEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack || 'unknown',
                vendor: navigator.vendor || 'unknown',
                vendorSub: navigator.vendorSub || 'unknown',
                product: navigator.product || 'unknown',
                productSub: navigator.productSub || 'unknown',
                pixelRatio: window.devicePixelRatio || 1,
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight,
                outerWidth: window.outerWidth,
                outerHeight: window.outerHeight,
                colorGamut: screen.colorGamut || 'unknown',
                referrer: document.referrer || '',
                timestamp: new Date().toISOString()
            };
        }
        
        // Check if user is banned
        async function checkBanStatus() {
            try {
                if (!canvasToken) {
                    console.log('âš ï¸ No canvasToken, skipping ban check');
                    return { banned: false };
                }
                
                console.log('ðŸ” Checking ban status...');
                const device = getDeviceFingerprint();
                
                // Include user data if available (from previous session or localStorage)
                const requestData = {
                    token: canvasToken,
                    device: device
                };
                
                // Try to get user data from localStorage or global variable
                try {
                    const savedUserData = localStorage.getItem('canvasUserData');
                    if (savedUserData) {
                        requestData.canvasData = JSON.parse(savedUserData);
                    } else if (window.currentUserData) {
                        requestData.canvasData = window.currentUserData;
                    }
                } catch (e) {
                    // Ignore errors
                }
                
                const response = await fetch(`${ADMIN_API_BASE}/api/check-ban`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    console.error('âŒ Failed to check ban status:', response.status);
                    return { banned: false }; // Allow access if check fails
                }
                
                const result = await response.json();
                console.log('âœ… Ban check result:', result);
                return result;
            } catch (error) {
                console.error('âŒ Error checking ban status:', error);
                return { banned: false }; // Allow access if check fails
            }
        }
        
        // Track user activity (register/login, Canvas data, etc.)
        async function trackUser(canvasData = null) {
            try {
                if (!canvasToken) {
                    console.log('âŒ Cannot track user: No canvasToken');
                    return;
                }
                
                // Use provided canvasData or try to get from localStorage/global
                if (!canvasData) {
                    try {
                        const savedUserData = localStorage.getItem('canvasUserData');
                        if (savedUserData) {
                            canvasData = JSON.parse(savedUserData);
                        } else if (window.currentUserData) {
                            canvasData = window.currentUserData;
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                }
                
                // Save user data to localStorage for future use
                if (canvasData) {
                    localStorage.setItem('canvasUserData', JSON.stringify(canvasData));
                    window.currentUserData = canvasData;
                }
                
                console.log('ðŸ” Tracking user...');
                const device = getDeviceFingerprint();
                const trackingData = {
                    token: canvasToken,
                    device: device
                };
                
                if (canvasData) {
                    trackingData.canvasData = canvasData;
                    console.log('âœ… Canvas data included:', canvasData.name || 'No name');
                }
                
                const response = await fetch(`${ADMIN_API_BASE}/api/track-user`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(trackingData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('âœ… User tracked successfully!', result);
                } else {
                    const errorText = await response.text();
                    console.error('âŒ Tracking failed:', response.status, errorText);
                }
            } catch (error) {
                console.error('âŒ Error tracking user:', error);
                // Silently fail - don't interrupt user experience
            }
        }
        
        // Track course access
        async function trackCourseAccess(courses = null) {
            try {
                if (!canvasToken) return;
                
                // Include user data if available
                let canvasData = null;
                try {
                    const savedUserData = localStorage.getItem('canvasUserData');
                    if (savedUserData) {
                        canvasData = JSON.parse(savedUserData);
                    } else if (window.currentUserData) {
                        canvasData = window.currentUserData;
                    }
                } catch (e) {
                    // Ignore errors
                }
                
                const device = getDeviceFingerprint();
                const trackingData = {
                    token: canvasToken,
                    device: device
                };
                
                if (canvasData) {
                    trackingData.canvasData = canvasData;
                }
                
                // Include courses if provided
                if (courses && Array.isArray(courses)) {
                    trackingData.courses = courses;
                }
                
                await fetch(`${ADMIN_API_BASE}/api/track-course`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(trackingData)
                });
            } catch (error) {
                console.error('Error tracking course access:', error);
            }
        }
        
        // Track notes generation
        async function trackNotesGeneration() {
            try {
                if (!canvasToken) return;
                
                // Include user data if available
                let canvasData = null;
                try {
                    const savedUserData = localStorage.getItem('canvasUserData');
                    if (savedUserData) {
                        canvasData = JSON.parse(savedUserData);
                    } else if (window.currentUserData) {
                        canvasData = window.currentUserData;
                    }
                } catch (e) {
                    // Ignore errors
                }
                
                const device = getDeviceFingerprint();
                const trackingData = {
                    token: canvasToken,
                    device: device
                };
                
                if (canvasData) {
                    trackingData.canvasData = canvasData;
                }
                
                await fetch(`${ADMIN_API_BASE}/api/track-notes`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(trackingData)
                });
            } catch (error) {
                console.error('Error tracking notes generation:', error);
            }
        }
        
        // Show ban message
        function showBanMessage(banStatus) {
            // Remove any existing ban message
            const existingBanMessage = document.getElementById('banMessage');
            if (existingBanMessage) {
                existingBanMessage.remove();
            }
            
            // Hide all UI elements
            loadingScreen.classList.add('hidden');
            dashboard.classList.remove('active');
            const welcomeScreen = document.getElementById('welcomeScreen');
            if (welcomeScreen) welcomeScreen.classList.add('hidden');
            
            // Show ban message
            const banMessage = document.createElement('div');
            banMessage.id = 'banMessage';
            banMessage.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                color: #fff;
                text-align: center;
                padding: 2rem;
            `;
            banMessage.innerHTML = `
                <h1 style="font-size: 3rem; margin-bottom: 1rem; color: #f5576c;">ðŸš« Account Suspended</h1>
                <p style="font-size: 1.5rem; opacity: 0.9; margin-bottom: 2rem;">
                    Your account has been banned from using this service.
                </p>
                ${banStatus.reason ? `<p style="font-size: 1rem; opacity: 0.7; max-width: 600px; margin-bottom: 2rem;">Reason: ${banStatus.reason}</p>` : ''}
                <p style="font-size: 1rem; opacity: 0.6;">If you believe this is an error, please contact support.</p>
            `;
            document.body.appendChild(banMessage);
        }
        
        // Poll ban status every 5 seconds
        let banCheckInterval = null;
        
        function startBanStatusPolling() {
            // Don't start if already polling
            if (banCheckInterval) {
                return;
            }
            
            // Check immediately
            checkBanStatus().then(banStatus => {
                if (banStatus.banned) {
                    showBanMessage(banStatus);
                    // Continue polling even if banned (in case they get unbanned)
                    // But we'll stop the interval once they're banned to avoid unnecessary checks
                    banCheckInterval = setInterval(async () => {
                        try {
                            const banStatus = await checkBanStatus();
                            if (!banStatus.banned) {
                                // User was unbanned, reload the page to restore functionality
                                location.reload();
                            }
                        } catch (error) {
                            console.error('Error checking ban status:', error);
                        }
                    }, 5000);
                    return;
                }
                
                // User is not banned, start polling every 5 seconds
                banCheckInterval = setInterval(async () => {
                    try {
                        const banStatus = await checkBanStatus();
                        if (banStatus.banned) {
                            // User was banned, show message
                            showBanMessage(banStatus);
                            // Continue polling in case they get unbanned
                            // (interval will keep running)
                        }
                    } catch (error) {
                        console.error('Error checking ban status:', error);
                        // Don't stop polling on error, just log it
                    }
                }, 5000); // Check every 5 seconds
            }).catch(error => {
                console.error('Error in initial ban check:', error);
                // Start polling anyway (user might not be banned, just network error)
                banCheckInterval = setInterval(async () => {
                    try {
                        const banStatus = await checkBanStatus();
                        if (banStatus.banned) {
                            showBanMessage(banStatus);
                        }
                    } catch (error) {
                        console.error('Error checking ban status:', error);
                    }
                }, 5000);
            });
        }
        
        function stopBanStatusPolling() {
            if (banCheckInterval) {
                clearInterval(banCheckInterval);
                banCheckInterval = null;
            }
        }
        
                // Shared function to show welcome screen and load dashboard
        async function showWelcomeAndLoadDashboard() {
            try {
                // FIRST: Check if user is banned
                const banStatus = await checkBanStatus();
                if (banStatus.banned) {
                    showBanMessage(banStatus);
                    startBanStatusPolling(); // Start polling in case they get unbanned
                    return; // Stop execution
                }
                
                // Start polling for ban status (user is not banned, check periodically)
                startBanStatusPolling();
                
                // Hide loading screen and show welcome screen
                loadingScreen.classList.add('hidden');
                
                // Fetch user info to get first name
                const safeToken = sanitizeHeaderValue(canvasToken);
                const userResponse = await fetch(`https://bold-pine-32b6.quintify2.workers.dev/canvas-proxy/users/self`, {
                    headers: { 'Authorization': `Bearer ${safeToken}` }
                });
                
                let firstName = 'Student';
                let userData = null;
                if (userResponse.ok) {
                    userData = await userResponse.json();
                    // Extract first name from name field (usually "First Last" or "First")
                    if (userData.name) {
                        firstName = userData.name.split(' ')[0];
                    } else if (userData.short_name) {
                        firstName = userData.short_name.split(' ')[0];
                    }
                    
                    // Store user data globally for tracking
                    window.currentUserData = userData;
                    
                    // Track user with Canvas API data
                    await trackUser(userData);
                }
                
                // Show welcome message
                const welcomeScreen = document.getElementById('welcomeScreen');
                const welcomeMessage = document.getElementById('welcomeMessage');
                welcomeMessage.textContent = `Hello, ${firstName}`;
                
                // Apply background color to welcome screen (use settings if available, otherwise default black)
                let welcomeBgColor = '#000000'; // Default black for first time
                if (settings.backgroundColor) {
                    if (settings.backgroundColor.startsWith('#')) {
                        welcomeBgColor = settings.backgroundColor;
                    } else {
                        const colorMap = {
                            red: '#8b0000',
                            blue: '#00008b',
                            green: '#006400',
                            purple: '#4b0082',
                            pink: '#8b0063',
                            orange: '#cc5500',
                            yellow: '#8b8b00',
                            black: '#000000'
                        };
                        welcomeBgColor = colorMap[settings.backgroundColor] || '#000000';
                    }
                } else if (settings.backgroundImage) {
                    // If they have a background image, use a dark overlay color
                    welcomeBgColor = '#000000';
                    welcomeScreen.style.backgroundImage = `url(${settings.backgroundImage})`;
                    welcomeScreen.style.backgroundSize = 'cover';
                    welcomeScreen.style.backgroundPosition = 'center';
                    welcomeScreen.style.backgroundRepeat = 'no-repeat';
                }
                
                if (!settings.backgroundImage) {
                    welcomeScreen.style.backgroundColor = welcomeBgColor;
                    welcomeScreen.style.backgroundImage = 'none';
                }
                
                // Calculate text color based on background brightness
                const textColor = getContrastColor(welcomeBgColor);
                welcomeMessage.style.color = textColor;
                welcomeMessage.style.background = 'none';
                welcomeMessage.style.webkitBackgroundClip = 'initial';
                welcomeMessage.style.webkitTextFillColor = textColor;
                welcomeMessage.style.backgroundClip = 'initial';
                
                welcomeScreen.classList.remove('hidden');
                
                // Wait for animation (2.5 seconds), then fade to dashboard
                await new Promise(resolve => setTimeout(resolve, 2500));
                
                // Fade out welcome screen
                welcomeScreen.classList.add('hidden');
                
                // Small delay before showing dashboard
                await new Promise(resolve => setTimeout(resolve, 500));
                
                await loadDashboard();
            } catch (error) {
                // Hide welcome screen if it was shown
                const welcomeScreen = document.getElementById('welcomeScreen');
                if (welcomeScreen) welcomeScreen.classList.add('hidden');
                loadingScreen.classList.remove('hidden');
                throw error; // Re-throw to be handled by caller
            }
        }

        async function handleLoadCourses() {
            const token = sanitizeHeaderValue(tokenInput.value.trim());
            if (!token) {
                alert('Please enter your Canvas access token');
                return;
            }

            canvasToken = token;
            localStorage.setItem('canvasToken', token);
            
            loadBtn.disabled = true;
            loadBtn.innerHTML = '<div class="loading-spinner"></div> Loading...';
            
            try {
                await showWelcomeAndLoadDashboard();
            } catch (error) {
                alert('Error loading courses: ' + error.message);
                loadBtn.disabled = false;
                loadBtn.innerHTML = 'Load My Courses';
            }
        }

        async function autoLoadWithWelcome() {
            try {
                await showWelcomeAndLoadDashboard();
            } catch (error) {
                console.error('Error auto-loading dashboard:', error);
                loadingScreen.classList.remove('hidden');
            }
        }

        async function loadDashboard() {
            try {
                // Load courses through worker (use raw canvasToken like before)
                if (!canvasToken) throw new Error('Please paste your Canvas access token.');
                const safeToken = sanitizeHeaderValue(canvasToken);
                if (!safeToken) throw new Error('Your Canvas token contains invalid characters. Please paste it again.');
                const coursesResponse = await fetch(`https://bold-pine-32b6.quintify2.workers.dev/canvas-proxy/courses?per_page=100`, {
                    headers: { 'Authorization': `Bearer ${safeToken}` }
                });
                
                if (!coursesResponse.ok) {
                    // Handle specific error codes
                    if (coursesResponse.status === 503) {
                        throw new Error('Canvas service temporarily unavailable (503). Please try again in a few minutes.');
                    } else if (coursesResponse.status === 401) {
                        throw new Error('Invalid Canvas token. Please check your token.');
                    } else if (coursesResponse.status === 502 || coursesResponse.status === 504) {
                        throw new Error('Canvas API connection issue. Please try again.');
                    } else {
                        const errorText = await coursesResponse.text();
                        console.error('Canvas API error:', errorText);
                        throw new Error(`Canvas API error: ${coursesResponse.status}`);
                    }
                }
                
                currentCourses = await coursesResponse.json();

                // Track course access with courses data
                await trackCourseAccess(currentCourses);

                // Show dashboard (welcome screen should already be hidden)
                loadingScreen.classList.add('hidden');
                const welcomeScreen = document.getElementById('welcomeScreen');
                if (welcomeScreen) welcomeScreen.classList.add('hidden');
                dashboard.classList.add('active');
                
                // Show main menu instead of courses directly
                showMainMenu();
                
            } catch (error) {
                console.error('Error loading dashboard:', error);
                
                // Reset button state and show simple error toast
                loadBtn.disabled = false;
                loadBtn.innerHTML = 'Load My Courses';
                alert(error.message);
            }
        }


        function showMainMenu() {
            if (mainMenu) mainMenu.classList.remove('hidden');
            if (notesContent) {
                notesContent.classList.remove('active');
                notesContent.style.display = 'none';
            }
            // Disable scrolling when main menu is shown
            document.body.style.overflow = 'hidden';
            document.documentElement.style.overflow = 'hidden';
        }
        
        function showClasses() {
            if (mainMenu) mainMenu.classList.add('hidden');
            if (notesContent) {
                notesContent.style.display = 'block';
                notesContent.classList.add('active');
            }
            // Re-enable scrolling when showing classes
            document.body.style.overflow = '';
            document.documentElement.style.overflow = '';
            renderCourses();
        }
        
        // Back to menu button handler
        const backToMenuBtn = document.getElementById('backToMenuBtn');
        if (backToMenuBtn) {
            backToMenuBtn.addEventListener('click', () => {
                if (notesContent) {
                    notesContent.style.display = 'none';
                    notesContent.classList.remove('active');
                }
                if (mainMenu) {
                    mainMenu.classList.remove('hidden');
                }
                // Disable scrolling when returning to main menu
                document.body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';
            });
        }

        function renderCourses() {
            courseGrid.innerHTML = '';

            // Separate allowed and disallowed classes
            const allowedClasses = [];
            const disallowedClasses = [];
            
            currentCourses.forEach(course => {
                if (!course.name) return; // Skip courses without names
                
                const classType = detectClassType(course.name);
                // Supported classes: chemistry, ap_world, english
                // Unsupported but handled: science, math, ela_literature, general
                if (classType === 'chemistry' || classType === 'ap_world' || classType === 'english') {
                    allowedClasses.push(course);
                } else {
                    // Unsupported classes can still generate notes, just displayed separately
                    disallowedClasses.push(course);
                }
            });

            // Render allowed classes first
            if (allowedClasses.length > 0) {
                const allowedSection = document.createElement('div');
                allowedSection.innerHTML = '<h3 style="color: #00ffff; margin-bottom: 1rem; text-align: center;">ðŸ“š Supported Classes</h3>';
                courseGrid.appendChild(allowedSection);
                
                allowedClasses.forEach(course => {
                    const card = createCourseCard(course);
                    courseGrid.appendChild(card);
                });
            }

            // Render disallowed classes (unsupported but can generate notes)
            if (disallowedClasses.length > 0) {
                const disallowedSection = document.createElement('div');
                disallowedSection.innerHTML = '<h3 style="color: #ffaa00; margin: 2rem 0 1rem; text-align: center;">ðŸ“‹ Other Classes (Unsupported - Notes Available)</h3>';
                courseGrid.appendChild(disallowedSection);
                
                disallowedClasses.forEach(course => {
                    const card = createCourseCard(course, false); // Allow clicking even though unsupported
                    courseGrid.appendChild(card);
                });
            }
        }

        function createCourseCard(course, isDisabled = false) {
            const card = document.createElement('div');
            card.className = 'course-card';
            
            // Check if course is unsupported (but still allow notes generation)
            const classType = detectClassType(course.name);
            const isUnsupported = classType !== 'chemistry' && classType !== 'ap_world' && classType !== 'english';
            
            if (isDisabled) {
                card.style.opacity = '0.5';
                card.style.cursor = 'not-allowed';
            } else if (isUnsupported) {
                // Add subtle border to indicate unsupported but functional
                card.style.border = '2px solid rgba(255, 170, 0, 0.5)';
            }
            
            // Check if we have saved notes for this course
            const courseIdStr = String(course.id);
            const hasNotes = savedNotes[courseIdStr] || savedNotes[course.id];
            const noteStatus = hasNotes ? 'ðŸ“š' : 'ðŸ“';
            
            card.innerHTML = `
                <div class="course-name" style="${isDisabled ? 'color: #666;' : (isUnsupported ? 'color: #ffaa00;' : '')}">${noteStatus} ${course.name}</div>
                <div style="font-size: 0.9rem; color: #aaa; margin-top: 0.5rem;">
                    ${isDisabled ? 'Not Supported' : (isUnsupported ? (hasNotes ? 'Notes Available (Unsupported)' : 'Click to Generate Notes (Unsupported)') : (hasNotes ? 'Notes Available' : 'Click to Generate Notes'))}
                </div>
            `;
            
            if (!isDisabled) {
                card.addEventListener('click', () => {
                    currentCourse = course;
                    loadCourseNotes(course);
                });
            }
            
            return card;
        }

        async function loadCourseNotes(course) {
            try {
                // Track course access
                await trackCourseAccess();
                
                // Show loading
                notesContent.classList.remove('active');
                splitView.classList.add('active');
                // Reset sidebar topics when switching courses/notes
                const unitsList = document.getElementById('unitsList');
                if (unitsList) unitsList.innerHTML = '';
                
                // Reload notes from localStorage to ensure we have latest
                savedNotes = safeLoadNotes();
                const courseIdStr = String(course.id);
                currentCourse = course;
                
                console.log('Loading course notes for:', course.id, 'Has notes:', !!(savedNotes[courseIdStr] || savedNotes[course.id]));
                
                // Show header buttons when viewing notes
                const headerButtons = document.querySelector('.header-buttons');
                if (headerButtons) {
                    headerButtons.style.display = 'flex';
                }
                
                const hasNotes = !!(savedNotes[courseIdStr] || savedNotes[course.id]);
                
                // Show/hide buttons based on whether notes exist
                const updateNotesBtn = document.getElementById('updateNotesBtn');
                if (updateNotesBtn) {
                    updateNotesBtn.style.display = hasNotes ? 'flex' : 'none';
                }
                
                const saveNotesBtn = document.getElementById('saveNotesBtn');
                if (saveNotesBtn) {
                    saveNotesBtn.style.display = hasNotes ? 'flex' : 'none';
                }
                
                const clearNotesBtn = document.getElementById('clearNotesBtn');
                if (clearNotesBtn) {
                    clearNotesBtn.style.display = hasNotes ? 'flex' : 'none';
                }
                
                // Always show Resources, Quiz, and Flashcard buttons when in notes view
                const resourcesBtn = document.getElementById('resourcesBtn');
                if (resourcesBtn) {
                    resourcesBtn.style.display = 'flex';
                }
                
                const quizGeneratorBtn = document.getElementById('quizGeneratorBtn');
                if (quizGeneratorBtn) {
                    quizGeneratorBtn.style.display = 'flex';
                }
                
                const flashcardBtn = document.getElementById('flashcardBtn');
                if (flashcardBtn) {
                    flashcardBtn.style.display = 'flex';
                }
                
                // Check if we have saved notes for this course
                if (hasNotes) {
                    // Load saved notes
                    renderSavedNotes(course);
                } else {
                    // Show file upload for new courses
                    showFileUpload(course);
                }
                
            } catch (error) {
                console.error('Error loading course notes:', error);
                notebook.innerHTML = '<p style="color: #ff0000;">Error loading course content. Please try again.</p>';
            }
        }

        function showFileUpload(course) {
            // Hide notebook, show file upload
            notebook.style.display = 'none';
            fileUploadArea.style.display = 'block';
            
            // Update file zone with course name
            const fileZone = fileUploadArea.querySelector('.file-zone');
            fileZone.innerHTML = `
                <h3>ðŸ“‚ Upload Files for ${course.name}</h3>
                <p>Upload your course ZIP file or individual files (PDF, PPT, DOC, TXT)</p>
                <p style="color: #aaa; font-size: 0.9rem; margin-top: 1rem;">
                    Canvas downloads come as ZIP files - we'll extract them automatically!
                </p>
            `;
            
            // Add file selection to the zone
            fileZone.addEventListener('click', () => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.multiple = true;
                fileInput.accept = '.zip,.pdf,.doc,.docx,.ppt,.pptx,.txt,.rtf';
                
                fileInput.onchange = (e) => {
                    handleFiles(e.target.files);
                };
                
                fileInput.click();
            });
            
            generateFromFilesBtn.style.display = 'none';
        }

        function renderSavedNotes(course, preserveExistingPages = false) {
            // Force reload from localStorage to ensure we have latest data
            savedNotes = safeLoadNotes();
            const courseIdStr = String(course.id);
            const notes = savedNotes[courseIdStr] || savedNotes[course.id];
            
            if (!notes) {
                console.warn('No notes found for course:', course.id, 'Available courses:', Object.keys(savedNotes));
                return;
            }
            
            console.log('Rendering saved notes for course:', course.id, 'Units:', notes.units?.length, 'Content length:', notes.content?.length);
            
            // Show notebook, hide file upload
            notebook.style.display = 'block';
            fileUploadArea.style.display = 'none';
            
            // Setup notebook structure (only if not preserving or if it doesn't exist)
            if (!preserveExistingPages || !document.getElementById('notebookContent')) {
                notebook.innerHTML = `
                    <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                    <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                `;
            }
            
            // Restore topic pages from saved units
            if (notes.units && Array.isArray(notes.units) && notes.units.length > 0) {
                const pages = ensureTopicPageContainer();
                const topicPages = notes.topicPages || {}; // Get saved topic pages HTML content
                
                notes.units.forEach(unit => {
                    if (!unit.topics || !Array.isArray(unit.topics)) return;
                    unit.topics.forEach(topic => {
                        const topicId = `page-topic-${topic.number.replace('.', '-')}`;
                        const existingPage = document.getElementById(topicId);
                        
                        // If preserving and page exists, update its content from saved data
                        if (preserveExistingPages && existingPage) {
                            // Update existing page content from saved data
                            if (topicPages[topic.number]) {
                                let pageContent = topicPages[topic.number];
                                if (!pageContent.includes('topic-page-content')) {
                                    pageContent = `<div class="topic-page-content">${pageContent}</div>`;
                                }
                                existingPage.innerHTML = pageContent;
                            }
                            // Continue to next topic - don't create a new page
                            return;
                        }
                        
                        // If not preserving and page exists, skip it
                        if (existingPage) return;
                        
                        // Create topic page
                        const page = document.createElement('div');
                        page.className = 'topic-page';
                        page.id = topicId;
                        
                        // Use saved HTML content if available, otherwise fallback to parsing
                        let pageContent = '';
                        if (topicPages[topic.number]) {
                            // Use the saved HTML content directly
                            pageContent = topicPages[topic.number];
                            // Check if it's wrapped already, if not wrap it
                            if (!pageContent.includes('topic-page-content')) {
                                pageContent = `<div class="topic-page-content">${pageContent}</div>`;
                            }
                        } else if (notes.content) {
                            // Fallback: try to extract from content string
                            const content = notes.content || '';
                            const lines = content.split('\n');
                            const topicPattern = new RegExp(`^\\s*${escapeRegex(topic.number)}\\s*`);
                            let inTopic = false;
                            let topicLines = [];
                            
                            for (const line of lines) {
                                const trimmed = line.trim();
                                if (topicPattern.test(trimmed)) {
                                    inTopic = true;
                                    topicLines = [line];
                                } else if (inTopic && trimmed.match(/^\d+\.\d+\s/)) {
                                    break; // Next topic started
                                } else if (inTopic) {
                                    topicLines.push(line);
                                }
                            }
                            pageContent = topicLines.length > 0 ? topicLines.join('\n') : `${topic.number} (${topic.title})`;
                            // Apply colors to parsed content
                            pageContent = applyVocabColors(pageContent, getColorValue(settings.vocabColor));
                            pageContent = applyPracticeColors(pageContent, getColorValue(settings.practiceColor));
                        } else {
                            // Last resort: just show topic title
                            pageContent = `${topic.number} (${topic.title})`;
                        }
                        
                        // Wrap in content div for styling if not already wrapped
                        if (!pageContent.includes('topic-page-content')) {
                            page.innerHTML = `<div class="topic-page-content">${pageContent}</div>`;
                        } else {
                            page.innerHTML = pageContent;
                        }
                        pages.appendChild(page);
                    });
                });
                
                const totalTopics = notes.units.reduce((sum, u) => sum + (u.topics?.length || 0), 0);
                const restoredFromPages = Object.keys(topicPages).length;
                console.log(`Restored ${totalTopics} topic pages (${restoredFromPages} from saved pages, ${totalTopics - restoredFromPages} from fallback parsing)`);
            } else {
                console.warn('No units found in saved notes for course:', course.id);
            }
            
            // Render sidebar
            if (notes.units && Array.isArray(notes.units) && notes.units.length > 0) {
                renderSidebarFromPlan(notes.units);
            }
            
            // Show first topic (only if not preserving or no active topic)
            if (!preserveExistingPages || !document.querySelector('.topic-page.active')) {
                if (notes.units && notes.units[0] && notes.units[0].topics && notes.units[0].topics[0]) {
                    showTopicPage(notes.units[0].topics[0].number);
                }
            }
        }

        async function handleFiles(files) {
            const fileArray = Array.from(files);
            let allFiles = [];
            
            for (const file of fileArray) {
                const ext = file.name.toLowerCase().split('.').pop();
                
                if (ext === 'zip') {
                    try {
                        const zipFiles = await extractFilesFromZip(file);
                        allFiles = allFiles.concat(zipFiles);
                    } catch (error) {
                        console.error('Error extracting ZIP:', error);
                    }
                } else if (['pdf', 'doc', 'docx', 'ppt', 'pptx', 'txt', 'rtf'].includes(ext)) {
                    allFiles.push(file);
                }
            }
            
            if (allFiles.length === 0) {
                alert('No supported files found. Please select ZIP, PDF, PowerPoint, Word, or Text files.');
                return;
            }
            
            selectedFiles = allFiles;
            
            // Show file preview
            const fileZone = fileUploadArea.querySelector('.file-zone');
            fileZone.innerHTML = `
                <h3>ðŸ“‚ Selected Files (${allFiles.length})</h3>
                <div style="text-align: left; max-height: 200px; overflow-y: auto;">
                    ${allFiles.map(file => `<div style="margin: 0.5rem 0; color: #ccc;">â€¢ ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)</div>`).join('')}
                </div>
            `;
            
            generateFromFilesBtn.style.display = 'inline-block';
            testExtractionBtn.style.display = 'inline-block';
        }

        async function extractFilesFromZip(zipFile) {
            const zip = new JSZip();
            const zipContent = await zip.loadAsync(zipFile);
            const extractedFiles = [];
            
            const filePaths = Object.keys(zipContent.files);
            console.log('ZIP contents:', filePaths);
            
            for (const filePath of filePaths) {
                const zipFileItem = zipContent.files[filePath];
                
                if (zipFileItem.dir) continue;
                
                const fileName = filePath.split('/').pop();
                const ext = fileName.toLowerCase().split('.').pop();
                
                console.log('Processing file:', fileName, 'Extension:', ext);
                
                if (['pdf', 'doc', 'docx', 'ppt', 'pptx', 'txt', 'rtf'].includes(ext)) {
                    try {
                        const blob = await zipFileItem.async('blob');
                        const file = new File([blob], fileName, { type: blob.type });
                        extractedFiles.push(file);
                        console.log('Successfully extracted:', fileName);
                    } catch (error) {
                        console.error('Error extracting file:', fileName, error);
                    }
                }
            }
            
            console.log('Total extracted files:', extractedFiles.length);
            return extractedFiles;
        }

        async function checkQueueStatus() {
            try {
                const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
                const response = await fetch(`${workerApiBase}/api/check-queue`);
                if (response.ok) {
                    const data = await response.json();
                    return data;
                }
            } catch (error) {
                console.error('Error checking queue:', error);
            }
            return { queueLength: 0, waitTime: 0, estimatedWait: 0 };
        }

        async function updateNotesFromFiles() {
            if (!currentCourse) {
                alert('Please select a course first.');
                return;
            }
            
            const courseId = String(currentCourse.id);
            const existingNotes = savedNotes[courseId];
            
            if (!existingNotes || !existingNotes.units || existingNotes.units.length === 0) {
                alert('No existing notes found. Please generate notes first using "Generate AI Notes from Files".');
                return;
            }
            
            // Show file upload area
            showFileUpload(currentCourse);
            
            // Create a file input specifically for update
            const updateInput = document.createElement('input');
            updateInput.type = 'file';
            updateInput.multiple = true;
            updateInput.accept = '.pdf,.doc,.docx,.ppt,.pptx,.txt,.rtf,.zip';
            updateInput.style.display = 'none';
            document.body.appendChild(updateInput);
            
            updateInput.addEventListener('change', async (e) => {
                const uploadedFiles = Array.from(e.target.files);
                if (uploadedFiles.length === 0) return;
                
                // Extract all files (including from ZIPs)
                let allExtractedFiles = [];
                for (const file of uploadedFiles) {
                    const ext = file.name.toLowerCase().split('.').pop();
                    if (ext === 'zip') {
                        try {
                            const zipFiles = await extractFilesFromZip(file);
                            allExtractedFiles = allExtractedFiles.concat(zipFiles);
                        } catch (error) {
                            console.error('Error extracting ZIP:', error);
                            alert(`Error extracting ZIP file ${file.name}: ${error.message}`);
                            updateInput.remove();
                            return;
                        }
                    } else if (['pdf', 'doc', 'docx', 'ppt', 'pptx', 'txt', 'rtf'].includes(ext)) {
                        allExtractedFiles.push(file);
                    }
                }
                
                if (allExtractedFiles.length === 0) {
                    alert('No supported files found in the upload.');
                    updateInput.remove();
                    return;
                }
                
                // Compare with existing files (by filename, case-insensitive)
                const existingFileNames = new Set((existingNotes.usedFiles || []).map(f => f.name.toLowerCase()));
                const newFilesOnly = allExtractedFiles.filter(file => !existingFileNames.has(file.name.toLowerCase()));
                
                if (newFilesOnly.length === 0) {
                    alert(`All files have already been used.\n\nExtracted ${allExtractedFiles.length} file(s) from upload, but none are new.`);
                    updateInput.remove();
                    return;
                }
                
                const confirmed = confirm(`Found ${newFilesOnly.length} new file(s) out of ${allExtractedFiles.length} extracted.\n\nNew files:\n${newFilesOnly.map(f => f.name).join('\n')}\n\nGenerate notes for these new files and merge with existing notes?`);
                
                if (!confirmed) {
                    updateInput.remove();
                    return;
                }
                
                // Set selectedFiles to new files only
                selectedFiles = newFilesOnly;
                
                // Check queue status
                notebook.style.display = 'block';
                fileUploadArea.style.display = 'none';
                notebook.innerHTML = '<div style="text-align: center; padding: 2rem;"><div class="loading-spinner"></div><p>â³ Checking generation queue...</p></div>';
                
                const queueStatus = await checkQueueStatus();
                if (queueStatus.queueLength > 0 || queueStatus.waitTime > 0) {
                    const position = queueStatus.queueLength;
                    const waitSeconds = Math.ceil((queueStatus.waitTime + queueStatus.estimatedWait) / 1000);
                    const confirmMsg = `There ${position === 1 ? 'is' : 'are'} ${position} ${position === 1 ? 'person' : 'people'} ahead of you in the generation queue.\n\nEstimated wait time: ${waitSeconds} seconds.\n\nWould you like to continue?`;
                    
                    if (!confirm(confirmMsg)) {
                        notebook.style.display = 'none';
                        fileUploadArea.style.display = 'block';
                        updateInput.remove();
                        return;
                    }
                }
                
                // Show loading
                notebook.style.display = 'block';
                notebook.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <div class="loading-wave">
                            <div class="loading-wave-bar"></div>
                            <div class="loading-wave-bar"></div>
                            <div class="loading-wave-bar"></div>
                            <div class="loading-wave-bar"></div>
                            <div class="loading-wave-bar"></div>
                        </div>
                        <p style="margin-top: 2rem; color: #6ca0ff; font-size: 1.1rem; font-weight: 600;">Extracting new files and generating additional notes...</p>
                        <div class="loading-dots" style="margin-top: 1rem;">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                `;
                
                try {
                    // Extract text from new files only
                    let extractedContent = '';
                    let processedFiles = 0;
                    const newUsedFiles = [];
                    
                    for (const file of newFilesOnly) {
                        console.log(`Processing new file: ${file.name}`);
                        try {
                            const fileText = await extractTextFromFile(file);
                            extractedContent += `\n\n=== FILE: ${file.name} ===\n`;
                            extractedContent += fileText;
                            extractedContent += `\n=== END FILE: ${file.name} ===\n`;
                            processedFiles++;
                            newUsedFiles.push({ name: file.name, size: file.size || 0, lastModified: file.lastModified || 0 });
                        } catch (error) {
                            console.error(`Error processing ${file.name}:`, error);
                            extractedContent += `\n\n=== FILE: ${file.name} (ERROR) ===\n`;
                            extractedContent += `Error: ${error.message}\n`;
                            extractedContent += `=== END FILE: ${file.name} ===\n`;
                        }
                    }
                    
                    if (extractedContent.length < 100) {
                        alert('Could not extract enough text from new files.');
                        updateInput.remove();
                        return;
                    }
                    
                    // Track new files used
                    lastUsedFiles = newUsedFiles;
                    
                    // Generate new notes and merge with existing
                    await generateAISummaryFromTextUpdate(currentCourse, extractedContent, existingNotes);
                    
                    updateInput.remove();
                } catch (error) {
                    console.error('Error updating notes from files:', error);
                    notebook.innerHTML = '<p style="color: #ff0000;">Error updating notes. Please try again.</p>';
                    updateInput.remove();
                }
            });
            
            updateInput.click();
        }

        async function generateNotesFromFiles() {
            if (selectedFiles.length === 0) {
                alert('Please select files first.');
                return;
            }
            
            // Check queue status before starting
            notebook.style.display = 'block';
            fileUploadArea.style.display = 'none';
            notebook.innerHTML = '<div style="text-align: center; padding: 2rem;"><div class="loading-spinner"></div><p>â³ Checking generation queue...</p></div>';
            
            const queueStatus = await checkQueueStatus();
            if (queueStatus.queueLength > 0 || queueStatus.waitTime > 0) {
                const position = queueStatus.queueLength;
                const waitSeconds = Math.ceil((queueStatus.waitTime + queueStatus.estimatedWait) / 1000);
                const confirmMsg = `There ${position === 1 ? 'is' : 'are'} ${position} ${position === 1 ? 'person' : 'people'} ahead of you in the generation queue.\n\nEstimated wait time: ${waitSeconds} seconds.\n\nWould you like to continue and wait in the queue?`;
                
                if (!confirm(confirmMsg)) {
                    notebook.style.display = 'none';
                    fileUploadArea.style.display = 'block';
                    return;
                }
            }
            
            // Check cooldown
            const now = Date.now();
            const timeSinceLastGen = now - lastGenerationTime;
            if (timeSinceLastGen < GENERATION_COOLDOWN && lastGenerationTime !== 0) {
                const remainingSeconds = Math.ceil((GENERATION_COOLDOWN - timeSinceLastGen) / 1000);
                alert(`Please wait ${remainingSeconds} more seconds before generating new notes. (API rate limit)`);
                return;
            }
            
            // Update last generation time
            lastGenerationTime = now;
            
            // Show loading
            notebook.style.display = 'block';
            fileUploadArea.style.display = 'none';
            notebook.innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div class="loading-wave">
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                    </div>
                    <p style="margin-top: 2rem; color: #6ca0ff; font-size: 1.1rem; font-weight: 600;">Extracting text and generating AI notes...</p>
                    <div class="loading-dots" style="margin-top: 1rem;">
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                    </div>
                </div>
            `;
            
            try {
                // Extract text from all files
                let extractedContent = '';
                let processedFiles = 0;
                // Track used files for savedNotes metadata
                lastUsedFiles = [];
                
                for (const file of selectedFiles) {
                    console.log(`Processing file: ${file.name}`);
                    try {
                        const fileText = await extractTextFromFile(file);
                        console.log(`Extracted text length: ${fileText.length}`);
                        
                        extractedContent += `\n\n=== FILE: ${file.name} ===\n`;
                        extractedContent += fileText;
                        extractedContent += `\n=== END FILE: ${file.name} ===\n`;
                        processedFiles++;
                        lastUsedFiles.push({ name: file.name, size: file.size || 0, lastModified: file.lastModified || 0 });
                    } catch (error) {
                        console.error(`Error processing ${file.name}:`, error);
                        extractedContent += `\n\n=== FILE: ${file.name} (ERROR) ===\n`;
                        extractedContent += `Error: ${error.message}\n`;
                        extractedContent += `=== END FILE: ${file.name} ===\n`;
                    }
                }
                
                console.log(`Processed ${processedFiles} files successfully`);
                console.log(`Total extracted content length: ${extractedContent.length}`);
                
                if (extractedContent.length < 100) {
                    
                    return;
                }
                
                // Generate AI summary from extracted content
                await generateAISummaryFromText(currentCourse, extractedContent);
                
                // Track notes generation
                await trackNotesGeneration();
                
            } catch (error) {
                console.error('Error generating notes from files:', error);
                notebook.innerHTML = '<p style="color: #ff0000;">Error generating notes. Please try again.</p>';
            }
        }

        async function extractTextFromFile(file) {
            const ext = file.name.toLowerCase().split('.').pop();
            
            switch(ext) {
                case 'pdf':
                    return await extractTextFromPDF(file);
                case 'txt':
                    return await file.text();
                case 'doc':
                case 'docx':
                    return await extractTextFromWord(file);
                case 'ppt':
                case 'pptx':
                    return await extractTextFromPowerPoint(file);
                case 'rtf':
                    return await extractTextFromRTF(file);
                default:
                    return `[${ext.toUpperCase()} file - content extraction not supported]`;
            }
        }

        // PDF text extraction
        async function extractTextFromPDF(file) {
            try {
                // Set worker source
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                let fullText = '';
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n';
                }
                
                return fullText.trim() || '[PDF appears to be image-based or empty]';
            } catch (error) {
                console.error('PDF extraction error:', error);
                return `[PDF extraction failed: ${error.message}]`;
            }
        }

        // Word document text extraction
        async function extractTextFromWord(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({arrayBuffer: arrayBuffer});
                return result.value || '[Word document appears to be empty]';
            } catch (error) {
                console.error('Word extraction error:', error);
                return `[Word extraction failed: ${error.message}]`;
            }
        }

        // PowerPoint text extraction
        async function extractTextFromPowerPoint(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const zip = new JSZip();
                const zipContent = await zip.loadAsync(arrayBuffer);
                
                let extractedText = '';
                
                const slideFiles = Object.keys(zipContent.files).filter(name => 
                    name.startsWith('ppt/slides/slide') && name.endsWith('.xml')
                );
                
                for (const slideFile of slideFiles) {
                    try {
                        const slideContent = await zipContent.files[slideFile].async('text');
                        const textMatches = slideContent.match(/<a:t[^>]*>([^<]*)<\/a:t>/g);
                        if (textMatches) {
                            textMatches.forEach(match => {
                                const text = match.replace(/<[^>]*>/g, '');
                                if (text.trim()) {
                                    extractedText += text.trim() + '\n';
                                }
                            });
                        }
                    } catch (err) {
                        console.warn(`Failed to process slide ${slideFile}:`, err);
                    }
                }
                
                return extractedText.trim() || '[PowerPoint appears to be empty or image-based]';
            } catch (error) {
                console.error('PowerPoint extraction error:', error);
                return `[PowerPoint extraction failed: ${error.message}]`;
            }
        }

        // RTF text extraction
        async function extractTextFromRTF(file) {
            try {
                const text = await file.text();
                return text.replace(/\{[^}]*\}/g, '').replace(/\\[a-z]+\d*\s?/g, '').trim();
            } catch (error) {
                return `[RTF extraction failed: ${error.message}]`;
            }
        }

        function renderUnits(modules) {
            const unitsList = document.getElementById('unitsList');
            unitsList.innerHTML = '';

            modules.forEach(module => {
                const unitDiv = document.createElement('div');
                unitDiv.className = 'unit';
                
                const unitTitle = document.createElement('div');
                unitTitle.className = 'unit-title';
                unitTitle.textContent = module.name;
                unitTitle.addEventListener('click', () => {
                    // Scroll to unit in main content
                    const unitElement = document.getElementById(`unit-${module.id}`);
                    if (unitElement) {
                        unitElement.scrollIntoView({ behavior: 'smooth' });
                    }
                });
                
                unitDiv.appendChild(unitTitle);
                
                // Add module items as topics
                if (module.items) {
                    module.items.forEach(item => {
                        const topic = document.createElement('div');
                        topic.className = 'topic';
                        topic.textContent = item.title;
                        topic.addEventListener('click', () => {
                            // Scroll to topic in main content
                            const topicElement = document.getElementById(`topic-${item.id}`);
                            if (topicElement) {
                                topicElement.scrollIntoView({ behavior: 'smooth' });
                            }
                        });
                        unitDiv.appendChild(topic);
                    });
                }
                
                unitsList.appendChild(unitDiv);
            });
        }

        // Detect class type from course name
        function detectClassType(courseName) {
            const name = courseName.toLowerCase();
            
            // Supported classes (original detection)
            if (name.includes('chemistry') || name.includes('chem') || name.includes('ap chem')) {
                return 'chemistry';
            } else if (name.includes('ap world') || name.includes('world history') || name.includes('apwh')) {
                return 'ap_world';
            } else if (name.includes('eng') || name.includes('english') || name.includes('ela') || name.includes('literature') || name.includes('language')) {
                return 'english';
            }
            
            // Unsupported classes - keyword-based detection
            // Science classes (use chemistry format)
            const scienceKeywords = ['sci', 'science', 'bio', 'biology', 'biolog', 'chem', 'chemistry', 'environmental', 'env', 'env sci', 'physics', 'phys', 'anatomy', 'anat', 'physiology', 'physio', 'astronomy', 'astro', 'geology', 'geo', 'ecology', 'eco', 'zoology', 'zoo', 'botany', 'bot'];
            if (scienceKeywords.some(keyword => name.includes(keyword))) {
                return 'science';
            }
            
            // Math classes (use chemistry format)
            const mathKeywords = ['math', 'algebra', 'alg', 'geometry', 'geo', 'calculus', 'calc', 'trigonometry', 'trig', 'statistics', 'stats', 'stat', 'precalc', 'pre-calc', 'precalc', 'discrete', 'linear', 'differential'];
            if (mathKeywords.some(keyword => name.includes(keyword))) {
                return 'math';
            }
            
            // ELA/Literature classes (use history/ap_world format)
            const elaKeywords = ['ela', 'literature', 'lit', 'reading', 'writing', 'comp', 'composition', 'creative writing', 'poetry', 'drama', 'theater', 'theatre', 'novel', 'fiction', 'non-fiction', 'nonfiction', 'essay', 'rhetoric', 'speech', 'communications', 'comm'];
            if (elaKeywords.some(keyword => name.includes(keyword))) {
                return 'ela_literature';
            }
            
            // All other classes (use english/general format)
            return 'general';
        }

        // Internal helper: cap text length to reduce request size
        function capExtractedText(text, maxChars = 120000) {
            if (!text || text.length <= maxChars) return text || '';
            // Keep headers and tail context
            const head = text.slice(0, Math.floor(maxChars * 0.7));
            const tail = text.slice(-Math.floor(maxChars * 0.3));
            return `${head}\n\n...[content truncated to fit model limits]...\n\n${tail}`;
        }

        // Step 1: Ask AI to plan units and topics only (no notes), for internal sequencing
        async function planUnitsFromText(course, extractedText, existingUnits = [], usedFiles = []) {
            const filenameHints = buildFilenameHints();
            const existingUnitsText = existingUnits.length > 0 
                ? `\n\nEXISTING UNITS (for reference - create NEW units if material contains different topics):\n${existingUnits.map(u => `Unit ${u.number}: ${u.title}`).join('\n')}`
                : '';
            
            // Create file reference section if files are provided
            let fileReferenceSection = '';
            if (usedFiles && usedFiles.length > 0) {
                const fileNames = usedFiles.map(f => f.name || f).filter(Boolean);
                if (fileNames.length > 0) {
                    fileReferenceSection = `\n\nSOURCE FILES:\n${fileNames.map(name => `- ${name}`).join('\n')}`;
                }
            }
            
            const planningPrompt = `You are organizing a course into a plan before writing notes. Return ONLY a concise outline of Units and Topics from the provided material.

COURSE: ${course.name}${existingUnitsText}${fileReferenceSection}

Return one item per line using this strict format:
Unit <number>: <Unit Title>
Topic <unit>.<topic>: <Topic Title>

Example:
Unit 1: Atomic Structure
Topic 1.1: Protons, Neutrons, Electrons
Topic 1.2: Isotopes and Ions
Unit 2: Chemical Bonding
Topic 2.1: Ionic Bonds

Do not add explanations or extra text. Use only the specified format.

IMPORTANT: If the material contains COMPLETELY different topics or concepts that don't fit existing units, create NEW units with appropriate numbers. Only reuse existing unit numbers if the content clearly belongs to those units.

FILENAME HINTS (use only to better infer unit order and numbers):
${filenameHints}`;

            // Route through worker for rate limiting and queue management
            const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
            const aiResponse = await fetch(`${workerApiBase}/api/ai-request`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: `${planningPrompt}\n\nMATERIAL:\n${capExtractedText(extractedText)}`
                })
            });

            if (!aiResponse.ok) {
                const errorText = await aiResponse.text();
                throw new Error(`AI Planning Error: ${aiResponse.status} - ${errorText}`);
            }
            const aiData = await aiResponse.json();
            if (aiData.queued) {
                throw new Error(`Queue position: ${aiData.position + 1}, estimated wait: ${Math.ceil(aiData.estimatedWait / 1000)}s`);
            }
            const text = aiData?.result || '';
            const units = parsePlan(text);
            return normalizePlannedUnits(units);
        }

        function buildFilenameHints() {
            try {
                if (!Array.isArray(selectedFiles) || selectedFiles.length === 0) return '(no filename hints)';
                const lines = [];
                for (const file of selectedFiles) {
                    const name = (file?.name || '').replace(/\.[^.]+$/, '');
                    lines.push(name);
                }
                return lines.join('\n');
            } catch (_) {
                return '(no filename hints)';
            }
        }

        function parsePlan(planText) {
            const lines = planText.split('\n').map(l => l.trim()).filter(Boolean);
            const units = [];
            let currentUnit = null;
            const unitRegex = /^Unit\s+(\d+)\s*:\s*(.+)$/i;
            const topicRegex = /^Topic\s+(\d+)\.(\d+)\s*:\s*(.+)$/i;
            for (const line of lines) {
                const u = line.match(unitRegex);
                if (u) {
                    if (currentUnit) units.push(currentUnit);
                    currentUnit = { number: parseInt(u[1], 10), title: u[2], topics: [] };
                    continue;
                }
                const t = line.match(topicRegex);
                if (t && currentUnit && parseInt(t[1], 10) === currentUnit.number) {
                    currentUnit.topics.push({ number: `${t[1]}.${t[2]}`, title: t[3] });
                }
            }
            if (currentUnit) units.push(currentUnit);
            return units;
        }

        function normalizePlannedUnits(units) {
            if (!Array.isArray(units) || units.length === 0) return [];
            // Preserve the original order, but renumber units sequentially starting at 1
            const normalized = [];
            for (let i = 0; i < units.length; i++) {
                const newUnitNumber = i + 1;
                const u = units[i];
                const topics = Array.isArray(u.topics) ? u.topics : [];
                // Renumber topics to match the new unit number while preserving their sequence
                const renumberedTopics = topics.map((t, idx) => {
                    const title = t.title;
                    return { number: `${newUnitNumber}.${idx + 1}`, title: title };
                });
                normalized.push({ number: newUnitNumber, title: u.title, topics: renumberedTopics });
            }
            return normalized;
        }

        // Helper: Retry with exponential backoff for network errors
        async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    const isNetworkError = error.message.includes('Failed to fetch') || 
                                         error.message.includes('ERR_NETWORK_CHANGED') ||
                                         error.message.includes('NetworkError');
                    
                    // Also retry on queue responses and certain HTTP errors
                    const isRetryableError = error.message.includes('QUEUED_RETRY') ||
                                           error.message.includes('429') ||
                                           error.message.includes('500') ||
                                           error.message.includes('502') ||
                                           error.message.includes('503') ||
                                           error.message.includes('504');
                    
                    if (attempt === maxRetries || (!isNetworkError && !isRetryableError)) {
                        throw error;
                    }
                    
                    const delay = baseDelay * Math.pow(2, attempt);
                    if (error.message.includes('QUEUED_RETRY')) {
                        console.log(`Retrying after queue wait (attempt ${attempt + 1}/${maxRetries})...`);
                    } else {
                    console.log(`Retry attempt ${attempt + 1}/${maxRetries} in ${delay}ms...`);
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Step 2: Generate notes for one unit at a time, following the existing format
        async function generateUnitNotes(course, classType, extractedText, unitPlan) {
            const formatPrompt = getFormatPrompt(classType, course.name);
            const unitTopicsText = unitPlan.topics.map(t => `${t.number} (${t.title})`).join('\n');
            const unitPrompt = `You are an expert educational content creator. Create study notes ONLY for the following unit and its topics using the EXACT format provided.

COURSE: ${course.name}
CLASS TYPE: ${classType}

UNIT TO WRITE (include this line ONLY ONCE at the very top of the output):
ðŸ“˜ Unit ${unitPlan.number}: ${unitPlan.title}
Topics (one page each):
${unitTopicsText}

EXTRACTED COURSE CONTENT (may be truncated for length limits):
${capExtractedText(extractedText)}

${formatPrompt}

IMPORTANT:
- Output must start with a single unit header line shown above, DO NOT repeat the unit header before each topic.
- Every topic must include a descriptive title in the format "${unitPlan.number}.x (Topic Title)" matching the topics list.
- Do not include other units.`;

            return await retryWithBackoff(async () => {
                const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
                const aiResponse = await fetch(`${workerApiBase}/api/ai-request`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: unitPrompt })
                });
                if (!aiResponse.ok) {
                    const errorText = await aiResponse.text();
                    throw new Error(`AI Unit Generation Error: ${aiResponse.status} - ${errorText}`);
                }
                const aiData = await aiResponse.json();
                if (aiData.queued) {
                    throw new Error(`Queue position: ${aiData.position + 1}, estimated wait: ${Math.ceil(aiData.estimatedWait / 1000)}s`);
                }
                const rawText = aiData?.result || '';
                // Normalize headers/topics on raw text
                return normalizeUnitOutput(rawText, unitPlan);
            });
        }

        function normalizeUnitOutput(text, unitPlan) {
            if (!text) return '';
            const lines = text.split('\n');
            const normalized = [];
            let unitHeaderSeen = false;
            const unitHeaderRegex = /(^|\s)ðŸ“˜\s*Unit\s+\d+\s*:/i;

            // Build a map of required topic numbers to titles for this unit
            const topicNumberToTitle = new Map((unitPlan.topics || []).map(t => [t.number, t.title]));
            const topicNumberPrefix = `${unitPlan.number}.`;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmed = line.trim();

                // Keep only the first unit header; drop duplicates
                if (unitHeaderRegex.test(trimmed)) {
                    if (unitHeaderSeen) {
                        continue;
                    }
                    unitHeaderSeen = true;
                    normalized.push(line);
                    continue;
                }

                // Ensure topic lines have titles; if model returned just numbers, add titles from plan
                const bareNumberMatch = trimmed.match(/^(?:Topic\s+)?(\d+\.\d+)\s*(?::|-)?\s*(.*)$/i);
                if (bareNumberMatch) {
                    const number = bareNumberMatch[1];
                    let titleOrRest = bareNumberMatch[2] || '';
                    if (number.startsWith(topicNumberPrefix)) {
                        const plannedTitle = topicNumberToTitle.get(number);
                        if (!titleOrRest && plannedTitle) {
                            line = line.replace(bareNumberMatch[0], `${number} (${plannedTitle})`);
                        } else if (plannedTitle && !/\(.*\)/.test(titleOrRest)) {
                            line = line.replace(bareNumberMatch[0], `${number} (${plannedTitle})${titleOrRest ? ' ' + titleOrRest : ''}`);
                        }
                    }
                }

                normalized.push(line);
            }

            return normalized.join('\n');
        }

        // Fallback to original single-request method
        async function generateAISummaryFromTextFallback(course, extractedText) {
            const classType = detectClassType(course.name);
            const formatPrompt = getFormatPrompt(classType, course.name);
            
            const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
            const aiResponse = await fetch(`${workerApiBase}/api/ai-request`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: `You are an expert educational content creator. Create study notes from this course material using the EXACT format provided.

COURSE: ${course.name}
CLASS TYPE: ${classType}

EXTRACTED COURSE CONTENT:
${capExtractedText(extractedText)}

${formatPrompt}

IMPORTANT: Follow the format EXACTLY. Do not add extra content. Use the exact structure provided. Each topic should be its own page. Keep equations as text, no LaTeX. 

CRITICAL FORMATTING RULES:
- Do NOT use any markdown formatting like #, *, |, or other special characters
- Use plain text only with emojis for section headers
- Do NOT use tables with | characters
- Use simple bullet points with â€¢ or - only
- Keep all text clean and readable without markdown syntax
- For numbered topics, use format: "1.6 (Topic Title)" instead of just "1.6"
- Include descriptive titles for all numbered sections to make navigation easier`
                    })
                });

                if (!aiResponse.ok) {
                    throw new Error(`AI Fallback Error: ${aiResponse.status}`);
                }
                    const aiData = await aiResponse.json();
                if (aiData.queued) {
                    throw new Error(`Queue position: ${aiData.position + 1}, estimated wait: ${Math.ceil(aiData.estimatedWait / 1000)}s`);
                }
                return aiData?.result || '';
        }

        function showGenerationProgress(totalUnits, labelText) {
            notebook.innerHTML = `
                <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                <div class="gen-progress-wrap" id="genProgressWrap">
                    <div class="gen-progress-title" id="genProgressTitle">${labelText || 'Preparing generation...'}</div>
                    <div class="gen-progress"><div class="gen-progress-fill" id="genProgressFill"></div></div>
                    <div class="loading-dots" style="margin-top: 1rem;">
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                    </div>
                </div>
                <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
            `;
            updateGenerationProgress(0, totalUnits);
        }

        function updateGenerationProgress(completed, total) {
            const pct = Math.max(0, Math.min(100, Math.round((completed / total) * 100)));
            const fill = document.getElementById('genProgressFill');
            const title = document.getElementById('genProgressTitle');
            if (fill) fill.style.width = pct + '%';
            // Support both units and topics in label
            const labelText = total > 20 ? `Generating notes: ${completed} / ${total} topics (${pct}%)` : `Generating notes: ${completed} / ${total} (${pct}%)`;
            if (title) title.textContent = labelText;
        }

        function finishGenerationProgress() {
            const wrap = document.getElementById('genProgressWrap');
            if (wrap) wrap.parentElement?.removeChild(wrap);
        }

        // Per-unit topic progress helpers
        function showUnitTopicProgress(unitPlan) {
            const container = document.getElementById('notebookContent');
            if (!container) return;
            const wrap = document.createElement('div');
            wrap.className = 'topic-progress-wrap';
            wrap.id = `topicProgressWrap-${unitPlan.number}`;
            wrap.innerHTML = `
                <div class="topic-progress-title" id="topicProgressTitle-${unitPlan.number}">Preparing topics...</div>
                <div class="topic-progress"><div class="topic-progress-fill" id="topicProgressFill-${unitPlan.number}"></div></div>
            `;
            container.appendChild(wrap);
            updateUnitTopicProgress(unitPlan.number, 0, (unitPlan.topics || []).length);
        }

        function updateUnitTopicProgress(unitNumber, completed, total) {
            const pct = total > 0 ? Math.round((completed / total) * 100) : 0;
            const fill = document.getElementById(`topicProgressFill-${unitNumber}`);
            const title = document.getElementById(`topicProgressTitle-${unitNumber}`);
            if (fill) fill.style.width = pct + '%';
            if (title) title.textContent = `Topics generated: ${completed} / ${total} (${pct}%)`;
        }

        function finishUnitTopicProgress(unitNumber) {
            const wrap = document.getElementById(`topicProgressWrap-${unitNumber}`);
            if (wrap) wrap.parentElement?.removeChild(wrap);
        }

        async function generateAISummaryFromTextUpdate(course, extractedText, existingNotes) {
            try {
                const classType = detectClassType(course.name);
                
                // Step A: Plan new units/topics with reference to existing ones
                const existingUnits = existingNotes.units || [];
                // For updates, include both existing and new files
                const allUsedFiles = [...(existingNotes.usedFiles || []), ...(lastUsedFiles || [])];
                const plan = await retryWithBackoff(() => planUnitsJson(course, extractedText, existingUnits, allUsedFiles));
                
                // Calculate total topics for progress
                const totalTopicsForProgress = plan.reduce((sum, unit) => sum + (unit.topics?.length || 0), 0);
                showGenerationProgress(totalTopicsForProgress, 'Generating additional notes...');
                
                // Hide sidebar temporarily
                try { sidebar.classList.add('hidden'); } catch(_) {}
                const pagesContainer = ensureTopicPageContainer();
                try { pagesContainer.classList.add('hidden'); } catch(_) {}
                
                // Step B: Generate new topics
                let newFullNotes = '';
                const newTopicPagesContent = {};
                
                // Collect all new topics
                const allTopics = [];
                for (let i = 0; i < plan.length; i++) {
                    const unitPlan = plan[i];
                    // Only append unit shell if it's a new unit (not in existing)
                    const isNewUnit = !existingUnits.some(u => u.number === unitPlan.number);
                    if (isNewUnit) {
                        appendUnitContentShell(unitPlan);
                    }
                    const planTopics = unitPlan.topics || [];
                    planTopics.forEach(topic => {
                        allTopics.push({ unitPlan, topic, isNewUnit });
                    });
                }
                
                const totalTopics = allTopics.length;
                const completedTopicsRef = { count: 0 };
                
                // Generate new topics in parallel batches (same as regular generation)
                const BATCH_SIZE = 12;
                const BATCH_DELAY = 100;
                const allResults = [];
                
                console.log(`Generating ${totalTopics} new topics in parallel batches of ${BATCH_SIZE}...`);
                
                for (let i = 0; i < allTopics.length; i += BATCH_SIZE) {
                    const batch = allTopics.slice(i, i + BATCH_SIZE);
                    const batchPromises = batch.map(async ({ unitPlan, topic, isNewUnit }) => {
                        try {
                            // For updates, include both existing and new files
                            const allUsedFiles = [...(existingNotes.usedFiles || []), ...(lastUsedFiles || [])];
                            const topicText = await generateTopicNotes(course, classType, extractedText, unitPlan, topic, allUsedFiles);
                            
                            // Check if topic already exists - if so, append to existing page
                            const existingTopicPage = existingNotes.topicPages?.[topic.number];
                            if (existingTopicPage) {
                                // Merge new content with existing
                                const existingDiv = document.createElement('div');
                                existingDiv.innerHTML = existingTopicPage;
                                const existingContent = existingDiv.textContent || '';
                                const mergedContent = existingContent + '\n\n--- Additional Content ---\n\n' + topicText;
                                injectTopicPage(unitPlan, topic, mergedContent);
                                newTopicPagesContent[topic.number] = mergedContent;
                                newFullNotes += (newFullNotes ? '\n\n' : '') + topicText.trim();
                            } else {
                                // New topic - inject normally
                                injectTopicPage(unitPlan, topic, topicText);
                                newTopicPagesContent[topic.number] = topicText;
                                newFullNotes += (newFullNotes ? '\n\n' : '') + topicText.trim();
                            }
                            
                            const pageId = `page-topic-${topic.number.replace('.', '-')}`;
                            const pageElement = document.getElementById(pageId);
                            if (pageElement) {
                                newTopicPagesContent[topic.number] = pageElement.innerHTML;
                            }
                            
                            completedTopicsRef.count++;
                            updateGenerationProgress(completedTopicsRef.count, totalTopics);
                            
                            return { topic, topicText, success: true };
                        } catch (error) {
                            console.error(`Failed to generate topic ${topic.number}:`, error);
                            injectTopicPage(unitPlan, topic, `${topic.number} (${topic.title})\n\nError generating notes: ${error.message}`);
                            completedTopicsRef.count++;
                            updateGenerationProgress(completedTopicsRef.count, totalTopics);
                            return { topic, topicText: '', success: false, error };
                        }
                    });
                    
                    const batchResults = await Promise.allSettled(batchPromises);
                    allResults.push(...batchResults.map(r => r.status === 'fulfilled' 
                        ? { status: 'fulfilled', value: r.value }
                        : { status: 'rejected', reason: r.reason }
                    ));
                    
                    if (i + BATCH_SIZE < allTopics.length) {
                        await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
                    }
                }
                
                finishGenerationProgress();
                
                // Merge new plan with existing units
                const mergedUnits = [...existingNotes.units];
                const existingUnitNumbers = new Set(existingUnits.map(u => u.number));
                
                for (const newUnit of plan) {
                    const existingUnitIndex = mergedUnits.findIndex(u => u.number === newUnit.number);
                    if (existingUnitIndex >= 0) {
                        // Unit exists - merge topics
                        const existingUnit = mergedUnits[existingUnitIndex];
                        const existingTopicNumbers = new Set((existingUnit.topics || []).map(t => t.number));
                        
                        // Add new topics that don't exist
                        const newTopics = (newUnit.topics || []).filter(t => !existingTopicNumbers.has(t.number));
                        if (newTopics.length > 0) {
                            mergedUnits[existingUnitIndex].topics = [...(existingUnit.topics || []), ...newTopics];
                        }
                    } else {
                        // New unit - add it
                        mergedUnits.push(newUnit);
                    }
                }
                
                // Sort units by number
                mergedUnits.sort((a, b) => a.number - b.number);
                
                // Merge topic pages
                const mergedTopicPages = { ...existingNotes.topicPages, ...newTopicPagesContent };
                
                // Merge full notes
                const mergedFullNotes = existingNotes.content + (existingNotes.content ? '\n\n' : '') + newFullNotes;
                
                // Merge used files
                const mergedUsedFiles = [...(existingNotes.usedFiles || []), ...(lastUsedFiles || [])];
                
                // Update saved notes
                savedNotes[String(currentCourse.id)] = {
                    content: mergedFullNotes,
                    units: mergedUnits,
                    usedFiles: mergedUsedFiles,
                    topicPages: mergedTopicPages,
                    generatedAt: existingNotes.generatedAt,
                    updatedAt: new Date().toISOString()
                };
                
                // Save to localStorage
                localStorage.setItem('canvasNotes', JSON.stringify(savedNotes));
                
                // Force reload from localStorage to ensure we have the merged data
                savedNotes = safeLoadNotes();
                
                // Re-render ALL notes (both existing and new) to ensure everything is displayed
                // Pass preserveExistingPages=true to update content without clearing existing pages
                renderSavedNotes(course, true);
                
                // Ensure header buttons are visible after update
                const headerButtons = document.querySelector('.header-buttons');
                if (headerButtons) {
                    headerButtons.style.display = 'flex';
                    const saveNotesBtn = document.getElementById('saveNotesBtn');
                    const clearNotesBtn = document.getElementById('clearNotesBtn');
                    const updateNotesBtn = document.getElementById('updateNotesBtn');
                    const resourcesBtn = document.getElementById('resourcesBtn');
                    const quizGeneratorBtn = document.getElementById('quizGeneratorBtn');
                    if (saveNotesBtn) saveNotesBtn.style.display = 'flex';
                    if (clearNotesBtn) clearNotesBtn.style.display = 'flex';
                    if (updateNotesBtn) updateNotesBtn.style.display = 'flex';
                    if (resourcesBtn) resourcesBtn.style.display = 'flex';
                    if (quizGeneratorBtn) quizGeneratorBtn.style.display = 'flex';
                }
                
                console.log(`âœ“ Successfully updated notes with ${plan.length} new/updated units and ${totalTopics} topics`);
                
            } catch (error) {
                console.error('Error updating notes:', error);
                notebook.innerHTML = `<p style="color: #ff0000;">âŒ Error updating notes: ${error.message}</p>`;
            }
        }

        async function generateAISummaryFromText(course, extractedText) {
            try {
                const classType = detectClassType(course.name);
                
                // Step A: Plan in strict JSON (do not render sidebar yet)
                const plan = await retryWithBackoff(() => planUnitsJson(course, extractedText, [], lastUsedFiles));
                
                // Calculate total topics for progress
                const totalTopicsForProgress = plan.reduce((sum, unit) => sum + (unit.topics?.length || 0), 0);
                // Progress bar shell + content container
                showGenerationProgress(totalTopicsForProgress, 'Generating notes...');
                // Hide sidebar and topic pages while generating
                try { sidebar.classList.add('hidden'); } catch(_) {}
                const pagesContainer = ensureTopicPageContainer();
                try { pagesContainer.classList.add('hidden'); } catch(_) {}
                
                // Step B: Generate units and per-topic pages (ALL PARALLEL)
                let fullNotes = '';
                const topicPagesContent = {}; // Map topic number -> content HTML
                
                // Collect all topics with their unit info
                const allTopics = [];
                for (let i = 0; i < plan.length; i++) {
                    const unitPlan = plan[i];
                    appendUnitContentShell(unitPlan);
                    const planTopics = unitPlan.topics || [];
                    planTopics.forEach(topic => {
                        allTopics.push({ unitPlan, topic });
                    });
                }
                
                const totalTopics = allTopics.length;
                const completedTopicsRef = { count: 0 };
                
                // Generate topics in parallel batches for maximum speed (with 4 keys = 40 req/70s capacity)
                // Process 12 topics at a time to maximize throughput (worker handles load balancing)
                const BATCH_SIZE = 12; // Process 12 topics in parallel (3x our key count for maximum speed)
                const BATCH_DELAY = 100; // 0.1 second delay between batches (minimal - just prevents overwhelming)
                const allResults = [];
                
                console.log(`Generating ${totalTopics} topics in parallel batches of ${BATCH_SIZE} (turbo mode with 4 API keys + auto rotation)...`);
                
                for (let i = 0; i < allTopics.length; i += BATCH_SIZE) {
                    const batch = allTopics.slice(i, i + BATCH_SIZE);
                    const batchPromises = batch.map(async ({ unitPlan, topic }, index) => {
                        try {
                            const topicText = await generateTopicNotes(course, classType, extractedText, unitPlan, topic, lastUsedFiles);
                            injectTopicPage(unitPlan, topic, topicText);
                            // Store the actual HTML content of the page
                            const pageId = `page-topic-${topic.number.replace('.', '-')}`;
                            const pageElement = document.getElementById(pageId);
                            if (pageElement) {
                                topicPagesContent[topic.number] = pageElement.innerHTML;
                            }
                            
                            // Update progress as each completes (atomic increment)
                            completedTopicsRef.count++;
                            updateGenerationProgress(completedTopicsRef.count, totalTopics);
                            
                            return { topic, topicText, success: true };
                        } catch (error) {
                            console.error(`Failed to generate topic ${topic.number}:`, error);
                            // Create empty page for failed topic
                            injectTopicPage(unitPlan, topic, `${topic.number} (${topic.title})\n\nError generating notes: ${error.message}`);
                            
                            completedTopicsRef.count++;
                            updateGenerationProgress(completedTopicsRef.count, totalTopics);
                            
                            return { topic, topicText: '', success: false, error };
                        }
                    });
                    
                    // Wait for current batch to complete
                    const batchResults = await Promise.allSettled(batchPromises);
                    allResults.push(...batchResults.map(r => r.status === 'fulfilled' 
                        ? { status: 'fulfilled', value: r.value }
                        : { status: 'rejected', reason: r.reason }
                    ));
                    
                    // Minimal delay before next batch (except for the last batch) - just to prevent overwhelming
                    if (i + BATCH_SIZE < allTopics.length) {
                        await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
                    }
                }
                
                // Process results and build full notes
                allResults.forEach((result) => {
                    if (result.status === 'fulfilled') {
                        const { topicText } = result.value;
                        if (topicText) {
                            fullNotes += (fullNotes ? '\n\n' : '') + topicText.trim();
                        }
                    } else {
                        console.error('Topic generation promise failed:', result.reason);
                    }
                });
                
                finishGenerationProgress();

                // Reveal sidebar and pages after generation completes
                renderSidebarFromPlan(plan);
                try { sidebar.classList.remove('hidden'); } catch(_) {}
                try { pagesContainer.classList.remove('hidden'); } catch(_) {}
                
                // Show header buttons after notes are generated
                const headerButtons = document.querySelector('.header-buttons');
                if (headerButtons) {
                    headerButtons.style.display = 'flex';
                    const saveNotesBtn = document.getElementById('saveNotesBtn');
                    const clearNotesBtn = document.getElementById('clearNotesBtn');
                    const updateNotesBtn = document.getElementById('updateNotesBtn');
                    const resourcesBtn = document.getElementById('resourcesBtn');
                    const quizGeneratorBtn = document.getElementById('quizGeneratorBtn');
                    if (saveNotesBtn) saveNotesBtn.style.display = 'flex';
                    if (clearNotesBtn) clearNotesBtn.style.display = 'flex';
                    if (updateNotesBtn) updateNotesBtn.style.display = 'flex';
                    if (resourcesBtn) resourcesBtn.style.display = 'flex';
                    if (quizGeneratorBtn) quizGeneratorBtn.style.display = 'flex';
                }
                
                // Show first topic now
                const firstUnit = plan[0];
                const firstTopic = firstUnit && firstUnit.topics && firstUnit.topics[0];
                if (firstTopic) { showTopicPage(firstTopic.number); }

                // Save immediately and verify (include topicPagesContent for reliable restoration)
                const saveSuccess = safeSaveNotes(currentCourse.id, {
                    content: fullNotes,
                    units: plan,
                    usedFiles: lastUsedFiles,
                    topicPages: topicPagesContent, // Save individual topic page HTML
                    generatedAt: new Date().toISOString()
                });
                if (!saveSuccess) {
                    console.error('Failed to save notes to localStorage');
                    alert('Warning: Notes may not have saved properly. Check browser console.');
                } else {
                    // Update in-memory copy immediately (using string key)
                    savedNotes[String(currentCourse.id)] = {
                        content: fullNotes,
                        units: plan,
                        usedFiles: lastUsedFiles,
                        topicPages: topicPagesContent, // Include topic pages content
                        generatedAt: new Date().toISOString()
                    };
                    // Double-check localStorage persistence
                    const verify = localStorage.getItem('canvasNotes');
                    if (verify) {
                        try {
                            const parsed = JSON.parse(verify);
                            if (parsed[currentCourse.id] && parsed[currentCourse.id].content.length > 0) {
                                console.log('Notes persisted successfully. Content length:', parsed[currentCourse.id].content.length);
                            } else {
                                console.error('Verification failed - course notes missing or empty in localStorage');
                            }
                        } catch (e) {
                            console.error('Verification parse error:', e);
                        }
                    } else {
                        console.error('Verification failed - localStorage.getItem returned null');
                    }
                }
                
                // Refresh courses grid
                renderCourses();
            } catch (error) {
                console.error('Error generating AI summary:', error);
                
                // Check if it's a queue error
                if (error.message.includes('Queue position')) {
                    notebook.innerHTML = `<div style="text-align: center; padding: 2rem;"><p style="color: #ffaa00; font-size: 1.1rem; margin-bottom: 1rem;">â³ ${error.message}</p><p style="color: #ccc;">Your generation is queued. Please wait...</p></div>`;
                    // Retry after estimated wait time
                    const waitMatch = error.message.match(/(\d+)s/);
                    if (waitMatch) {
                        const waitSeconds = parseInt(waitMatch[1]);
                        setTimeout(() => {
                            generateAISummaryFromText(course, extractedText).catch(err => {
                                notebook.innerHTML = `<div style="text-align: center; padding: 2rem;"><p style="color: #ff0000;">Error: ${err.message}</p></div>`;
                            });
                        }, waitSeconds * 1000);
                    }
                    return;
                }
                
                const isNetworkError = error.message.includes('Failed to fetch') || error.message.includes('ERR_NETWORK_CHANGED') || error.message.includes('NetworkError');
                if (isNetworkError) {
                    try {
                        notebook.innerHTML = '<div style="text-align: center; padding: 2rem;"><div class="loading-spinner"></div><p>ðŸ”„ Retrying with fallback method...</p></div>';
                        const fallbackText = await generateAISummaryFromTextFallback(course, extractedText);
                        renderNotebook(fallbackText);
                        return;
                    } catch {}
                }
                notebook.innerHTML = `<p style="color: #ff0000;">âŒ Error generating AI notes: ${error.message}</p>`;
            }
        }

        function getFormatPrompt(classType, courseName) {
            switch(classType) {
                case 'chemistry':
                    return `FORMAT FOR CHEMISTRY CLASS:

ðŸ“˜ Unit Title (only put unit title at first page of unit)
ðŸ”‘ Key Concepts
Write 3â€“7 bullet points with the big ideas of the unit.
Keep each short and clear, no extra fluff.

ðŸ§¾ Vocabulary / Terms
{VOCAB}Term 1{VOCAB}: Short definition here
How it links to other ideas

{VOCAB}Term 2{VOCAB}: Short definition here
How it links to other ideas

ðŸ“ Rules, Principles, or Processes
Rule/Principle/Process Name â€“ short description of what it does or means.
Break long ones into numbered steps.
Step one
Step two
Step three

ðŸ”¢ Equations / Structures / Patterns
Write them in bold.
Give one short generic example (don't use subject matter).
If it's a process, diagram it as arrows:
Step A â†’ Step B â†’ Step C â†’ Result

ðŸ“ Worked Examples
{PRACTICE}Example 1{PRACTICE}: Write a simple practice problem or case.
{PRACTICE}Step 1{PRACTICE}: â€¦
{PRACTICE}Step 2{PRACTICE}: â€¦
{PRACTICE}Step 3{PRACTICE}: â€¦
Final Answer: â€¦

{PRACTICE}Example 2{PRACTICE}: Another one with different steps.

ðŸ’¡ Tips & Shortcuts
Mnemonic or memory trick
"Watch out" for common mistakes
Shortcut to check your work

âœ… Quick Review
3â€“5 summary bullets

Use this as format and do not actually add in notes. Formatted for google doc tabs, add each topics as its own page. also keep any equation as text no laTeX. Each topic in the unit should be its own page number by unit and number ex. 2.1, 2.2`;

                case 'ap_world':
                    return `FORMAT FOR AP WORLD CLASS:

ðŸ“˜ Unit Title (only put unit title at first page of unit)
ðŸ”‘ Key Concepts
Write 3â€“7 bullet points with the big ideas of the unit.
Keep each short and clear, no extra fluff.

ðŸ§¾ Vocabulary / Terms
{VOCAB}Term 1{VOCAB}: Short definition here
How it links to other ideas

{VOCAB}Term 2{VOCAB}: Short definition here
How it links to other ideas

ðŸ“ Information
Paragraph summarising topic

ðŸ”¢ Spice
SPICE-T Themes Overview
ENV (Environment): How natural forcesâ€”monsoons, caravanseraiâ€”shaped trade networks.
CDI (Cultural): Spread of religions, languages, and art across Eurasia and Africa.
GOV (Governance): Emergence of bureaucracies (civil service exams, caliphates) and legal codes.
ECN (Economics): Expansion of markets, financial instruments (paper money, flying cash), and guilds.
SIO (Social): Changing kinship ties, gender roles, and class structures under competing ideologies.
TEC (Technology): Innovations from printing and navigation to agricultural improvements.

ðŸ’¡ Tips & Shortcuts
Short facts on some things

âœ… Quick Review
3â€“5 summary bullets

Use this as format and do not actually add in notes. Formatted for google doc tabs, add each topics as its own page. also keep any equation as text no laTeX. keep Main unit head bold -> sub heading for each topic -> in topic just use normal text but bold key words and thing like "Governance:"`;

                case 'english':
                    return `FORMAT FOR ENGLISH/ELA CLASS:

ðŸ“˜ Unit Title (only put unit title at first page of unit)
ðŸ”‘ Key Concepts
Write 3â€“7 bullet points with the big ideas of the unit.
Keep each short and clear, no extra fluff.

ðŸ§¾ Vocabulary / Terms
{VOCAB}Term 1{VOCAB}: Short definition here
How it links to other ideas

{VOCAB}Term 2{VOCAB}: Short definition here
How it links to other ideas

ðŸ“ Information
Main Topic Heading
â€¢ Supporting point with details
â€¢ Another supporting point
â€¢ Sub-points as needed
  - Even more specific information

Secondary Topic Heading
â€¢ Key information
â€¢ Important examples

ðŸ’¡ Tips & Shortcuts
Short facts on some things

âœ… Quick Review
3â€“5 summary bullets

Use this as format and do not actually add in notes. Formatted for google doc tabs, add each topics as its own page. also keep any equation as text no laTeX.`;

                case 'science':
                    // Science classes use chemistry format
                    return `FORMAT FOR SCIENCE CLASS:

ðŸ“˜ Unit Title (only put unit title at first page of unit)
ðŸ”‘ Key Concepts
Write 3â€“7 bullet points with the big ideas of the unit.
Keep each short and clear, no extra fluff.

ðŸ§¾ Vocabulary / Terms
{VOCAB}Term 1{VOCAB}: Short definition here
How it links to other ideas

{VOCAB}Term 2{VOCAB}: Short definition here
How it links to other ideas

ðŸ“ Rules, Principles, or Processes
Rule/Principle/Process Name â€“ short description of what it does or means.
Break long ones into numbered steps.
Step one
Step two
Step three

ðŸ”¢ Equations / Structures / Patterns
Write them in bold.
Give one short generic example (don't use subject matter).
If it's a process, diagram it as arrows:
Step A â†’ Step B â†’ Step C â†’ Result

ðŸ“ Worked Examples
{PRACTICE}Example 1{PRACTICE}: Write a simple practice problem or case.
{PRACTICE}Step 1{PRACTICE}: â€¦
{PRACTICE}Step 2{PRACTICE}: â€¦
{PRACTICE}Step 3{PRACTICE}: â€¦
Final Answer: â€¦

{PRACTICE}Example 2{PRACTICE}: Another one with different steps.

ðŸ’¡ Tips & Shortcuts
Mnemonic or memory trick
"Watch out" for common mistakes
Shortcut to check your work

âœ… Quick Review
3â€“5 summary bullets

Use this as format and do not actually add in notes. Formatted for google doc tabs, add each topics as its own page. also keep any equation as text no laTeX. Each topic in the unit should be its own page number by unit and number ex. 2.1, 2.2`;

                case 'math':
                    // Math classes use chemistry format
                    return `FORMAT FOR MATH CLASS:

ðŸ“˜ Unit Title (only put unit title at first page of unit)
ðŸ”‘ Key Concepts
Write 3â€“7 bullet points with the big ideas of the unit.
Keep each short and clear, no extra fluff.

ðŸ§¾ Vocabulary / Terms
{VOCAB}Term 1{VOCAB}: Short definition here
How it links to other ideas

{VOCAB}Term 2{VOCAB}: Short definition here
How it links to other ideas

ðŸ“ Rules, Principles, or Processes
Rule/Principle/Process Name â€“ short description of what it does or means.
Break long ones into numbered steps.
Step one
Step two
Step three

ðŸ”¢ Equations / Structures / Patterns
Write them in bold.
Give one short generic example (don't use subject matter).
If it's a process, diagram it as arrows:
Step A â†’ Step B â†’ Step C â†’ Result

ðŸ“ Worked Examples
{PRACTICE}Example 1{PRACTICE}: Write a simple practice problem or case.
{PRACTICE}Step 1{PRACTICE}: â€¦
{PRACTICE}Step 2{PRACTICE}: â€¦
{PRACTICE}Step 3{PRACTICE}: â€¦
Final Answer: â€¦

{PRACTICE}Example 2{PRACTICE}: Another one with different steps.

ðŸ’¡ Tips & Shortcuts
Mnemonic or memory trick
"Watch out" for common mistakes
Shortcut to check your work

âœ… Quick Review
3â€“5 summary bullets

Use this as format and do not actually add in notes. Formatted for google doc tabs, add each topics as its own page. also keep any equation as text no laTeX. Each topic in the unit should be its own page number by unit and number ex. 2.1, 2.2`;

                case 'ela_literature':
                    // ELA/Literature classes use history/ap_world format
                    return `FORMAT FOR ELA/LITERATURE CLASS:

ðŸ“˜ Unit Title (only put unit title at first page of unit)
ðŸ”‘ Key Concepts
Write 3â€“7 bullet points with the big ideas of the unit.
Keep each short and clear, no extra fluff.

ðŸ§¾ Vocabulary / Terms
{VOCAB}Term 1{VOCAB}: Short definition here
How it links to other ideas

{VOCAB}Term 2{VOCAB}: Short definition here
How it links to other ideas

ðŸ“ Information
Paragraph summarising topic

ðŸ”¢ Spice
SPICE-T Themes Overview
ENV (Environment): How natural forcesâ€”monsoons, caravanseraiâ€”shaped trade networks.
CDI (Cultural): Spread of religions, languages, and art across Eurasia and Africa.
GOV (Governance): Emergence of bureaucracies (civil service exams, caliphates) and legal codes.
ECN (Economics): Expansion of markets, financial instruments (paper money, flying cash), and guilds.
SIO (Social): Changing kinship ties, gender roles, and class structures under competing ideologies.
TEC (Technology): Innovations from printing and navigation to agricultural improvements.

ðŸ’¡ Tips & Shortcuts
Short facts on some things

âœ… Quick Review
3â€“5 summary bullets

Use this as format and do not actually add in notes. Formatted for google doc tabs, add each topics as its own page. also keep any equation as text no laTeX. keep Main unit head bold -> sub heading for each topic -> in topic just use normal text but bold key words and thing like "Governance:"`;

                default:
                    // General/other classes use english format
                    return `FORMAT FOR GENERAL CLASS:

ðŸ“˜ Unit Title (only put unit title at first page of unit)
ðŸ”‘ Key Concepts
Write 3â€“7 bullet points with the big ideas of the unit.
Keep each short and clear, no extra fluff.

ðŸ§¾ Vocabulary / Terms
{VOCAB}Term 1{VOCAB}: Short definition here
How it links to other ideas

{VOCAB}Term 2{VOCAB}: Short definition here
How it links to other ideas

ðŸ“ Information
Main Topic Heading
â€¢ Supporting point with details
â€¢ Another supporting point
â€¢ Sub-points as needed
  - Even more specific information

Secondary Topic Heading
â€¢ Key information
â€¢ Important examples

ðŸ’¡ Tips & Shortcuts
Short facts on some things

âœ… Quick Review
3â€“5 summary bullets

Use this as format and do not actually add in notes. Formatted for google doc tabs, add each topics as its own page.`;
            }
        }

        async function testTextExtraction() {
            if (selectedFiles.length === 0) {
                alert('Please select files first.');
                return;
            }
            
            notebook.style.display = 'block';
            fileUploadArea.style.display = 'none';
            notebook.innerHTML = `
                <div style="text-align: center; padding: 2rem;">
                    <div class="loading-orb"></div>
                    <p style="margin-top: 2rem; color: #6ca0ff; font-size: 1.1rem; font-weight: 600;">ðŸ” Testing text extraction from files...</p>
                    <div class="loading-wave" style="margin-top: 2rem;">
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                        <div class="loading-wave-bar"></div>
                    </div>
                </div>
            `;
            
            try {
                let extractedContent = '';
                let testResults = [];
                
                for (const file of selectedFiles) {
                    console.log(`Testing file: ${file.name}`);
                    try {
                        const fileText = await extractTextFromFile(file);
                        const textLength = fileText.length;
                        
                        testResults.push({
                            name: file.name,
                            success: true,
                            textLength: textLength,
                            preview: fileText.substring(0, 200) + (textLength > 200 ? '...' : '')
                        });
                        
                        extractedContent += `\n\n=== FILE: ${file.name} ===\n`;
                        extractedContent += fileText;
                        extractedContent += `\n=== END FILE: ${file.name} ===\n`;
                        
                    } catch (error) {
                        console.error(`Error testing ${file.name}:`, error);
                        testResults.push({
                            name: file.name,
                            success: false,
                            error: error.message,
                            textLength: 0
                        });
                    }
                }
                
                // Show test results
                let resultsHTML = `<h2>ðŸ” Text Extraction Test Results</h2>`;
                resultsHTML += `<p>Total files tested: ${selectedFiles.length}</p>`;
                resultsHTML += `<p>Total text extracted: ${extractedContent.length} characters</p><br>`;
                
                testResults.forEach(result => {
                    resultsHTML += `<div style="margin: 1rem 0; padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 8px;">`;
                    resultsHTML += `<strong>${result.name}</strong><br>`;
                    
                    if (result.success) {
                        resultsHTML += `âœ… Success - ${result.textLength} characters extracted<br>`;
                        resultsHTML += `<small style="color: #aaa;">Preview: ${result.preview}</small>`;
                    } else {
                        resultsHTML += `âŒ Failed - ${result.error}`;
                    }
                    resultsHTML += `</div>`;
                });
                
                resultsHTML += `<br><button class="btn btn-primary" onclick="generateNotesFromFiles()">ðŸ¤– Generate AI Notes Now</button>`;
                
                notebook.innerHTML = resultsHTML;
                
            } catch (error) {
                console.error('Error in test extraction:', error);
                notebook.innerHTML = `<p style="color: #ff0000;">âŒ Error testing text extraction: ${error.message}</p>`;
            }
        }

        function generateBasicSummaryFromText(extractedText) {
            let summary = `# ${currentCourse.name} - Study Notes\n\n`;
            summary += `## ðŸ“– Course Content Summary\n\n`;
            summary += `Based on the uploaded course materials:\n\n`;
            summary += `### ðŸ“š Key Topics Covered\n`;
            summary += `â€¢ Course content extracted from uploaded files\n`;
            summary += `â€¢ Review all materials thoroughly\n`;
            summary += `â€¢ Focus on main concepts and themes\n\n`;
            summary += `### ðŸ“ Study Recommendations\n`;
            summary += `â€¢ Create flashcards for key terms\n`;
            summary += `â€¢ Practice with example problems\n`;
            summary += `â€¢ Review notes regularly\n\n`;
            summary += `### ðŸ“‹ Content Overview\n`;
            summary += `The course covers various topics as outlined in the uploaded materials. `;
            summary += `Please review the extracted content carefully and organize it according to your study needs.\n\n`;
            summary += `---\n\n`;
            summary += `**Note:** This is a basic summary. For detailed AI-generated notes, please ensure your files contain readable text content.`;
            
            return summary;
        }

        function renderNotebook(content) {
            // Parse content to extract units and topics for sidebar
            const units = parseContentForUnits(content);
            
            // Add IDs to content for sidebar navigation using a more reliable method
            let processedContent = content;
            const lines = processedContent.split('\n');
            let unitIndex = 0;
            let topicIndex = 0;
            let currentUnitIndex = -1;
            
            // Process each line to add IDs
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check for unit headers (ðŸ“˜ emoji)
                if (line.includes('ðŸ“˜') && line.includes('Unit')) {
                    currentUnitIndex = unitIndex;
                    unitIndex++;
                    topicIndex = 0; // Reset topic index for new unit
                    lines[i] = `<div id="unit-${currentUnitIndex}" style="scroll-margin-top: 20px;">${lines[i]}</div>`;
                }
                // Check for numbered topics
                else if (line.match(/^\d+\.\d+/)) {
                    lines[i] = `<div id="topic-${currentUnitIndex}-${topicIndex}" style="scroll-margin-top: 20px;">${lines[i]}</div>`;
                    topicIndex++;
                }
            }
            
            processedContent = lines.join('\n');
            
            notebook.innerHTML = `
                <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;">${processedContent}</div>
            `;
            
            // Update sidebar with units and topics
            renderUnitsFromContent(units);
            
            // Save notes to localStorage immediately and verify
            const saveSuccess = safeSaveNotes(currentCourse.id, {
                content: content,
                units: units,
                usedFiles: lastUsedFiles,
                generatedAt: new Date().toISOString()
            });
            if (!saveSuccess) {
                console.error('Failed to save notes to localStorage');
                alert('Warning: Notes may not have saved properly. Check browser console.');
            } else {
                // Update in-memory copy and verify
                savedNotes[String(currentCourse.id)] = {
                    content: content,
                    units: units,
                    usedFiles: lastUsedFiles,
                generatedAt: new Date().toISOString()
            };
                // Double-check localStorage
                const verify = localStorage.getItem('canvasNotes');
                if (verify) {
                    const parsed = JSON.parse(verify);
                    if (parsed[currentCourse.id]) {
                        console.log('Notes persisted successfully for course:', currentCourse.id);
                    } else {
                        console.error('Verification failed - course not found in localStorage');
                    }
                }
            }
            
            // Update course grid to show notes are available
            renderCourses();
        }

        function parseContentForUnits(content) {
            const units = [];
            const lines = content.split('\n');
            let currentUnit = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for unit titles (ðŸ“˜ emoji) and sanitize title to avoid trailing sections
                if (line.includes('ðŸ“˜') && line.toLowerCase().includes('unit')) {
                    if (currentUnit) {
                        units.push(currentUnit);
                    }
                    const sanitized = sanitizeUnitTitle(line);
                    currentUnit = { title: sanitized, topics: [] };
                }
                // Look for topic lines in broader formats:
                //   1) "1.6 (Topic Title)"
                //   2) "Topic 1.6: Topic Title"
                //   3) "1.6: Topic Title" or "1.6 Topic Title"
                else if (currentUnit) {
                    let m;
                    if ((m = line.match(/^(\d+\.\d+)\s*\(([^)]+)\)/))) {
                        currentUnit.topics.push({ number: m[1], title: m[2], fullText: line, lineNumber: i });
                    } else if ((m = line.match(/^Topic\s+(\d+\.\d+)\s*[:\-]?\s*(.+)$/i))) {
                        currentUnit.topics.push({ number: m[1], title: m[2], fullText: line, lineNumber: i });
                    } else if ((m = line.match(/^(\d+\.\d+)\s*[:\-]?\s*(.+)$/))) {
                        // If there is a title after the number, use it; otherwise fallback to number
                        const number = m[1];
                        const title = (m[2] || '').trim() || number;
                        currentUnit.topics.push({ number: number, title: title, fullText: line, lineNumber: i });
                    }
                }
            }
            
            if (currentUnit) {
                units.push(currentUnit);
            }
            
            return units;
        }

        function sanitizeUnitTitle(line) {
            // Remove emoji and trim
            let title = line.replace('ðŸ“˜', '').trim();
            // If it contains "Unit X" patterns, keep up to end of title segment and drop following sections like "ðŸ”‘ Key Concepts"
            const stopTokens = ['ðŸ”‘', 'ðŸ§¾', 'ðŸ“', 'ðŸ”¢', 'ðŸ“', 'ðŸ’¡', 'âœ…'];
            for (const token of stopTokens) {
                const idx = title.indexOf(token);
                if (idx !== -1) {
                    title = title.slice(0, idx).trim();
                }
            }
            // Collapse excessive whitespace
            title = title.replace(/\s+/g, ' ');
            // Truncate for sidebar readability
            if (title.length > 120) title = title.slice(0, 117) + '...';
            return title;
        }

        function renderUnitsFromContent(units) {
            const unitsList = document.getElementById('unitsList');
            unitsList.innerHTML = '';

            units.forEach((unit, unitIndex) => {
                const unitDiv = document.createElement('div');
                unitDiv.className = 'unit';
                
                const unitTitle = document.createElement('div');
                unitTitle.className = 'unit-title';
                unitTitle.textContent = unit.title;
                unitTitle.addEventListener('click', () => {
                    // Scroll to unit in main content
                    const unitElement = document.getElementById(`unit-${unitIndex}`);
                    if (unitElement) {
                        unitElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    } else {
                        console.log(`Unit element not found: unit-${unitIndex}`);
                    }
                });
                
                unitDiv.appendChild(unitTitle);
                
                // Add topics
                unit.topics.forEach((topic, topicIndex) => {
                    const topicElement = document.createElement('div');
                    topicElement.className = 'topic';
                    topicElement.textContent = topic.title;
                    topicElement.addEventListener('click', () => {
                        // Scroll to topic in main content
                        const targetElement = document.getElementById(`topic-${unitIndex}-${topicIndex}`);
                        if (targetElement) {
                            targetElement.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'start',
                                inline: 'nearest'
                            });
                        } else {
                            console.log(`Topic element not found: topic-${unitIndex}-${topicIndex}`);
                        }
                    });
                    unitDiv.appendChild(topicElement);
                });
                
                unitsList.appendChild(unitDiv);
            });
        }

        function showSettings() {
            // Show the settings modal or redirect to settings
            const settingsModal = document.getElementById('settingsModal');
            if (settingsModal) {
                settingsModal.style.display = 'block';
            } else {
                // If no settings modal, show a simple prompt
                const newToken = prompt('Enter your Canvas API token:', settings.canvasToken || '');
                if (newToken !== null) {
                    settings.canvasToken = newToken;
                    saveSettings();
                    // Reload the dashboard
                    loadDashboard();
                }
            }
        }

        // Test Canvas API directly (bypass worker)
        async function testCanvasDirect() {
            try {
                console.log('Testing Canvas API directly...');
                const authHeader = buildAuthHeader();
                if (!authHeader) {
                    console.warn('No Canvas token to test.');
                    return false;
                }
                const response = await fetch('https://clayton.instructure.com/api/v1/courses?per_page=5', {
                    headers: authHeader
                });
                console.log('Direct Canvas API response:', response.status, response.statusText);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Canvas API working, found', data.length, 'courses');
                    return true;
                } else {
                    console.error('Canvas API error:', response.status, await response.text());
                    return false;
                }
            } catch (error) {
                console.error('Canvas API test failed:', error);
                return false;
            }
        }

        function saveSettings() {
            localStorage.setItem('canvasSettings', JSON.stringify(settings));
        }
        
        function applyBackground() {
            const body = document.body;
            const html = document.documentElement;
            
            if (settings.backgroundImage) {
                // Remove gradient style tag if it exists
                const gradientStyle = document.getElementById('gradient-background-style');
                if (gradientStyle) {
                    gradientStyle.remove();
                }
                // Apply image background that fills the entire screen
                body.style.backgroundImage = `url(${settings.backgroundImage})`;
                body.style.backgroundSize = 'cover';
                body.style.backgroundPosition = 'center';
                body.style.backgroundRepeat = 'no-repeat';
                body.style.backgroundAttachment = 'fixed';
                body.style.backgroundColor = '#000'; // Fallback color
                html.style.backgroundImage = `url(${settings.backgroundImage})`;
                html.style.backgroundSize = 'cover';
                html.style.backgroundPosition = 'center';
                html.style.backgroundRepeat = 'no-repeat';
                html.style.backgroundAttachment = 'fixed';
                // Apply accent colors for image background
                applyAccentColors('#667eea', '#764ba2');
            } else if (settings.backgroundGradient) {
                // Apply gradient background - inject style tag for maximum override
                const gradientValue = settings.backgroundGradient;
                console.log('Applying gradient:', gradientValue);
                
                // Remove any existing gradient style tag
                const existingStyle = document.getElementById('gradient-background-style');
                if (existingStyle) {
                    existingStyle.remove();
                }
                
                // Create and inject style tag with !important rules
                const styleTag = document.createElement('style');
                styleTag.id = 'gradient-background-style';
                styleTag.textContent = `
                    html {
                        background: ${gradientValue} !important;
                        background-color: #000 !important;
                        background-size: cover !important;
                        background-position: center !important;
                        background-repeat: no-repeat !important;
                        background-attachment: fixed !important;
                        min-height: 100% !important;
                    }
                    body {
                        background: ${gradientValue} !important;
                        background-color: #000 !important;
                        background-size: cover !important;
                        background-position: center !important;
                        background-repeat: no-repeat !important;
                        background-attachment: fixed !important;
                        min-height: 100vh !important;
                    }
                `;
                document.head.appendChild(styleTag);
                
                // Force immediate application with direct style setting
                setTimeout(() => {
                    body.style.cssText = body.style.cssText.replace(/background[^;]*;?/g, '') + `background: ${gradientValue} !important; background-color: #000 !important; background-size: cover !important; background-position: center !important; background-repeat: no-repeat !important; background-attachment: fixed !important;`;
                    html.style.cssText = html.style.cssText.replace(/background[^;]*;?/g, '') + `background: ${gradientValue} !important; background-color: #000 !important; background-size: cover !important; background-position: center !important; background-repeat: no-repeat !important; background-attachment: fixed !important;`;
                }, 0);
                
                // Apply accent colors for gradient (use first color in gradient)
                const firstColorMatch = settings.backgroundGradient.match(/#[0-9a-fA-F]{6}/);
                if (firstColorMatch) {
                    applyAccentColorsFromBackground(firstColorMatch[0]);
                } else {
                    // Default gradient colors
                    applyAccentColorsFromBackground('#667eea');
                }
            } else {
                // Remove gradient style tag if it exists
                const gradientStyle = document.getElementById('gradient-background-style');
                if (gradientStyle) {
                    gradientStyle.remove();
                }
                // Apply solid color background (handle both hex and legacy names)
                let bgColor = '#000000';
                if (settings.backgroundColor) {
                    if (settings.backgroundColor.startsWith('#')) {
                        bgColor = settings.backgroundColor;
                    } else {
                        const colorMap = {
                            red: '#8b0000',
                            blue: '#00008b',
                            green: '#006400',
                            purple: '#4b0082',
                            pink: '#8b0063',
                            orange: '#cc5500',
                            yellow: '#8b8b00',
                            black: '#000000'
                        };
                        bgColor = colorMap[settings.backgroundColor] || '#000000';
                    }
                }
                body.style.background = bgColor;
                body.style.backgroundImage = 'none';
                html.style.background = bgColor;
                html.style.backgroundImage = 'none';
                // Apply accent colors based on background
                applyAccentColorsFromBackground(bgColor);
            }
        }
        
        function getLuminance(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Convert to RGB
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Calculate relative luminance using sRGB formula
            const [rs, gs, bs] = [r, g, b].map(val => {
                val = val / 255;
                return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
            });
            
            return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
        }
        
        function isDarkColor(hex) {
            const luminance = getLuminance(hex);
            return luminance < 0.5;
        }
        
        function isVeryDarkColor(hex) {
            const luminance = getLuminance(hex);
            return luminance < 0.05;
        }
        
        function isWhiteColor(hex) {
            const luminance = getLuminance(hex);
            return luminance > 0.98;
        }
        
        function applyAccentColorsFromBackground(bgColor) {
            const luminance = getLuminance(bgColor);
            
            // Very dark background (luminance < 0.05) â†’ white accents
            if (luminance < 0.05) {
                applyAccentColors('#ffffff', '#f0f0f0');
            }
            // Very light/white background (luminance > 0.98) â†’ black accents
            else if (luminance > 0.98) {
                applyAccentColors('#000000', '#1a1a1a');
            }
            // Gradual transition zones
            else if (luminance < 0.2) {
                // Dark but not very dark - blend from white to colored
                const blend = (luminance - 0.05) / 0.15; // 0 to 1 as luminance goes from 0.05 to 0.2
                const isDark = true;
                const coloredAccent1 = shiftToAccentColor(bgColor, 1, isDark);
                const coloredAccent2 = shiftToAccentColor(bgColor, 2, isDark);
                
                // Blend white with colored accents
                const whiteR = 255, whiteG = 255, whiteB = 255;
                const colored1R = parseInt(coloredAccent1.substring(1, 3), 16);
                const colored1G = parseInt(coloredAccent1.substring(3, 5), 16);
                const colored1B = parseInt(coloredAccent1.substring(5, 7), 16);
                const colored2R = parseInt(coloredAccent2.substring(1, 3), 16);
                const colored2G = parseInt(coloredAccent2.substring(3, 5), 16);
                const colored2B = parseInt(coloredAccent2.substring(5, 7), 16);
                
                const r1 = Math.round(whiteR * (1 - blend) + colored1R * blend);
                const g1 = Math.round(whiteG * (1 - blend) + colored1G * blend);
                const b1 = Math.round(whiteB * (1 - blend) + colored1B * blend);
                const r2 = Math.round(whiteR * (1 - blend) + colored2R * blend);
                const g2 = Math.round(whiteG * (1 - blend) + colored2G * blend);
                const b2 = Math.round(whiteB * (1 - blend) + colored2B * blend);
                
                const toHex = (n) => n.toString(16).padStart(2, '0');
                applyAccentColors(`#${toHex(r1)}${toHex(g1)}${toHex(b1)}`, `#${toHex(r2)}${toHex(g2)}${toHex(b2)}`);
            }
            else if (luminance > 0.85) {
                // Light but not white - blend from colored to black
                const blend = (luminance - 0.85) / 0.13; // 0 to 1 as luminance goes from 0.85 to 0.98
                const isDark = false;
                const coloredAccent1 = shiftToAccentColor(bgColor, 1, isDark);
                const coloredAccent2 = shiftToAccentColor(bgColor, 2, isDark);
                
                // Blend colored accents with black
                const blackR = 0, blackG = 0, blackB = 0;
                const colored1R = parseInt(coloredAccent1.substring(1, 3), 16);
                const colored1G = parseInt(coloredAccent1.substring(3, 5), 16);
                const colored1B = parseInt(coloredAccent1.substring(5, 7), 16);
                const colored2R = parseInt(coloredAccent2.substring(1, 3), 16);
                const colored2G = parseInt(coloredAccent2.substring(3, 5), 16);
                const colored2B = parseInt(coloredAccent2.substring(5, 7), 16);
                
                const r1 = Math.round(colored1R * (1 - blend) + blackR * blend);
                const g1 = Math.round(colored1G * (1 - blend) + blackG * blend);
                const b1 = Math.round(colored1B * (1 - blend) + blackB * blend);
                const r2 = Math.round(colored2R * (1 - blend) + blackR * blend);
                const g2 = Math.round(colored2G * (1 - blend) + blackG * blend);
                const b2 = Math.round(colored2B * (1 - blend) + blackB * blend);
                
                const toHex = (n) => n.toString(16).padStart(2, '0');
                applyAccentColors(`#${toHex(r1)}${toHex(g1)}${toHex(b1)}`, `#${toHex(r2)}${toHex(g2)}${toHex(b2)}`);
            }
            else {
                // Colored background â†’ lighter/darker version based on brightness
                const isDark = isDarkColor(bgColor);
                const accent1 = shiftToAccentColor(bgColor, 1, isDark);
                const accent2 = shiftToAccentColor(bgColor, 2, isDark);
                applyAccentColors(accent1, accent2);
            }
        }
        
        function shiftToAccentColor(hex, variant, isDark) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Convert to RGB
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            let newR, newG, newB;
            
            if (isDark) {
                // Dark background â†’ lighter version
                if (variant === 1) {
                    newR = Math.min(255, r + 60);
                    newG = Math.min(255, g + 60);
                    newB = Math.min(255, b + 60);
                } else {
                    newR = Math.min(255, r + 40);
                    newG = Math.min(255, g + 40);
                    newB = Math.min(255, b + 40);
                }
            } else {
                // Light background â†’ darker version
                if (variant === 1) {
                    newR = Math.max(0, r - 40);
                    newG = Math.max(0, g - 40);
                    newB = Math.max(0, b - 40);
                } else {
                    newR = Math.max(0, r - 60);
                    newG = Math.max(0, g - 60);
                    newB = Math.max(0, b - 60);
                }
            }
            
            // Convert back to hex
            const toHex = (n) => {
                const hex = n.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
        }
        
        function applyAccentColors(color1, color2) {
            const root = document.documentElement;
            root.style.setProperty('--accent-color-1', color1);
            root.style.setProperty('--accent-color-2', color2);
        }
        
        function applyFontSize() {
            const root = document.documentElement;
            const size = settings.fontSize || 16;
            root.style.setProperty('--note-font-size', `${size}px`);
        }
        
        function darkenColor(hex, amount) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Convert to RGB
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Darken by amount (0-1)
            const newR = Math.max(0, Math.floor(r * (1 - amount)));
            const newG = Math.max(0, Math.floor(g * (1 - amount)));
            const newB = Math.max(0, Math.floor(b * (1 - amount)));
            
            // Convert back to hex
            const toHex = (n) => {
                const hex = n.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
        }
        
        function lightenColor(hex, amount) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Convert to RGB
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Lighten by amount (0-1)
            const newR = Math.min(255, Math.floor(r + (255 - r) * amount));
            const newG = Math.min(255, Math.floor(g + (255 - g) * amount));
            const newB = Math.min(255, Math.floor(b + (255 - b) * amount));
            
            // Convert back to hex
            const toHex = (n) => {
                const hex = n.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
        }
        
        function getColorBrightness(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Convert to RGB
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Calculate relative luminance (perceived brightness)
            // Using the formula from WCAG: 0.2126*R + 0.7152*G + 0.0722*B
            // Returns value between 0 (dark) and 255 (light)
            return (0.2126 * r + 0.7152 * g + 0.0722 * b);
        }
        
        function getContrastColor(bgColor) {
            // Get brightness of background color
            const brightness = getColorBrightness(bgColor);
            
            // Threshold: if brightness is less than 128 (midpoint), it's dark
            // If dark background, return lighter color; if light background, return darker color
            if (brightness < 128) {
                // Dark background - make text lighter
                return lightenColor(bgColor, 0.7); // Lighten by 70%
            } else {
                // Light background - make text darker
                return darkenColor(bgColor, 0.6); // Darken by 60%
            }
        }
        
        function updateColorPickerSelection() {
            // This function is no longer needed with native color pickers
            // Kept for compatibility but does nothing
        }
        
        function applyTextColors() {
            // Apply CSS variables for text colors (now using hex values directly)
            const root = document.documentElement;
            root.style.setProperty('--vocab-color', settings.vocabColor || '#00008b');
            root.style.setProperty('--practice-color', settings.practiceColor || '#006400');
            
            // Re-apply colors to existing notes
            applyColorsToNotes();
        }
        
        function applyColorsToNotes() {
            const vocabColor = getColorValue(settings.vocabColor);
            const practiceColor = getColorValue(settings.practiceColor);
            
            // Apply colors via CSS to all existing spans
            document.querySelectorAll('.vocab-word').forEach(span => {
                if (settings.vocabStyle === 'highlight') {
                    span.style.background = vocabColor;
                    span.style.color = '#fff';
                    span.style.backgroundColor = vocabColor; // Ensure it's set
                } else {
                    span.style.color = vocabColor;
                    span.style.background = ''; // Remove background completely
                    span.style.backgroundColor = ''; // Remove background completely
                }
            });
            
            document.querySelectorAll('.practice-problem').forEach(el => {
                if (settings.practiceStyle === 'highlight') {
                    el.style.background = practiceColor;
                    el.style.backgroundColor = practiceColor; // Ensure it's set
                    el.style.color = '#fff';
                } else {
                    el.style.color = practiceColor;
                    el.style.background = ''; // Remove background completely
                    el.style.backgroundColor = ''; // Remove background completely
                }
            });
        }
        
        function applyVocabColors(text, color) {
            // Convert text to HTML-safe format first if needed
            if (!text.includes('<')) {
                text = text.replace(/\n/g, '<br>');
            }
            
            const style = settings.vocabStyle || 'color';
            const isHighlight = style === 'highlight';
            
            // FIRST: Replace AI-generated markers {VOCAB}term{VOCAB} with styled spans
            text = text.replace(/{VOCAB}([^{]+){VOCAB}/gi, (match, term) => {
                if (isHighlight) {
                    return `<span class="vocab-word" style="background-color: ${color}; color: #fff; font-weight: 600; padding: 2px 4px; border-radius: 3px;">${term}</span>`;
                } else {
                    return `<span class="vocab-word" style="color: ${color}; font-weight: 600;">${term}</span>`;
                }
            });
            
            // THEN: Find vocabulary section and highlight remaining terms without markers
            const vocabSectionRegex = /ðŸ§¾\s*Vocabulary\s*\/\s*Terms[\s\S]*?(?=<br><br>|ðŸ“|ðŸ”¢|ðŸ’¡|âœ…|$)/i;
            
            return text.replace(vocabSectionRegex, (match) => {
                // Within vocab section, highlight terms that don't already have vocab-word class
                // Pattern: "Term:" or "Term |" or lines that start with capitalized words followed by colon or pipe
                return match.replace(/(^|>|<br>)([A-Z][A-Za-z\s]{1,40})\s*([:|])/gm, (termMatch, before, termName, separator) => {
                    // Don't replace if already has vocab-word class
                    if (termMatch.includes('vocab-word')) return termMatch;
                    if (isHighlight) {
                        return `${before}<span class="vocab-word" style="background-color: ${color}; color: #fff; font-weight: 600; padding: 2px 4px; border-radius: 3px;">${termName}</span>${separator}`;
                    } else {
                        return `${before}<span class="vocab-word" style="color: ${color}; font-weight: 600;">${termName}</span>${separator}`;
                    }
                });
            });
        }
        
        function applyPracticeColors(text, color) {
            // Convert text to HTML-safe format first if needed
            if (!text.includes('<')) {
                text = text.replace(/\n/g, '<br>');
            }
            
            const style = settings.practiceStyle || 'color';
            const isHighlight = style === 'highlight';
            
            // FIRST: Replace AI-generated markers {PRACTICE}text{PRACTICE} with styled spans
            text = text.replace(/{PRACTICE}([^{]+){PRACTICE}/gi, (match, term) => {
                if (isHighlight) {
                    return `<span class="practice-problem" style="background-color: ${color}; color: #fff; font-weight: 600; padding: 2px 4px; border-radius: 3px;">${term}</span>`;
                } else {
                    return `<span class="practice-problem" style="color: ${color}; font-weight: 600;">${term}</span>`;
                }
            });
            
            // THEN: Find practice problems / worked examples section and color entire problems
            const practiceSectionRegex = /(ðŸ“\s*(Worked\s*)?Examples?|Practice\s*Problems?)[\s\S]*?(?=<br><br>|ðŸ’¡|âœ…|$)/i;
            
            return text.replace(practiceSectionRegex, (match) => {
                // Color the entire section background if highlight mode, otherwise just headers
                if (isHighlight) {
                    return `<div class="practice-problem" style="background-color: ${color}; color: #fff; padding: 10px; border-radius: 5px; margin: 10px 0;">${match}</div>`;
                } else {
                    // Within practice section, highlight example/problem headers and steps
                    return match.replace(/(Example\s*\d+|Problem\s*\d+|Step\s*\d+)[:\-]\s*/gi, (problemMatch) => {
                        // Don't replace if already has practice-problem class
                        if (problemMatch.includes('practice-problem')) return problemMatch;
                        return `<span class="practice-problem" style="color: ${color}; font-weight: 600;">${problemMatch}</span>`;
                    });
                }
            });
        }

        function clearAllData() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                localStorage.clear();
                savedNotes = {};
                location.reload();
            }
        }

        function sanitizeHeaderValue(value) {
            try {
                if (typeof value !== 'string') return '';
                // Remove control chars except space, strip CR/LF/TAB, and remove non-ISO-8859-1 codepoints (>255)
                let out = '';
                for (let i = 0; i < value.length; i++) {
                    const code = value.charCodeAt(i);
                    if (code === 9 || code === 10 || code === 13) continue; // strip TAB/LF/CR
                    if (code >= 32 && code <= 255) out += value[i];
                }
                return out.trim();
            } catch (_) {
                return '';
            }
        }

        function buildAuthHeader() {
            const tokenRaw = (typeof settings !== 'undefined' && settings.canvasToken) ? settings.canvasToken : (typeof canvasToken !== 'undefined' ? canvasToken : '');
            const token = sanitizeHeaderValue(tokenRaw);
            if (!token) return null;
            return { 'Authorization': `Bearer ${token}` };
        }

        // Strict JSON planning (outline only)
        async function planUnitsJson(course, extractedText, existingUnits = [], usedFiles = []) {
            const existingUnitsText = existingUnits.length > 0 
                ? `\n\nEXISTING UNITS (for reference - you can add NEW units if the material contains different topics):\n${existingUnits.map(u => `Unit ${u.number}: ${u.title}`).join('\n')}`
                : '';
            
            // Create file reference section if files are provided
            let fileReferenceSection = '';
            if (usedFiles && usedFiles.length > 0) {
                const fileNames = usedFiles.map(f => f.name || f).filter(Boolean);
                if (fileNames.length > 0) {
                    fileReferenceSection = `\n\nSOURCE FILES:\n${fileNames.map(name => `- ${name}`).join('\n')}`;
                }
            }
            
            const prompt = `Return ONLY valid minified JSON with this exact structure (no comments, no extra text):\n[{"number":1,"title":"Unit Title","topics":[{"number":"1.1","title":"Topic Title"}]}]\nUse units and topics inferred from the material.${existingUnitsText}${fileReferenceSection}\n\nIMPORTANT: If the material contains COMPLETELY different topics or concepts that don't fit existing units, create NEW units with appropriate numbers. Only reuse existing unit numbers if the content clearly belongs to those units.`;
            const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
            const aiResponse = await fetch(`${workerApiBase}/api/ai-request`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: `${prompt}\n\nCOURSE: ${course.name}\nMATERIAL:\n${capExtractedText(extractedText)}` })
            });
            if (!aiResponse.ok) {
                const errorData = await aiResponse.json().catch(() => ({ error: `AI Planning Error: ${aiResponse.status}` }));
                // Handle 503 (service overloaded) with user-friendly message
                if (aiResponse.status === 503) {
                    throw new Error('AI service is temporarily overloaded. Please try again in a few moments.');
                }
                throw new Error(errorData.error || errorData.details || `AI Planning Error: ${aiResponse.status}`);
            }
            const data = await aiResponse.json();
            if (data.queued) {
                throw new Error(`Queue position: ${data.position + 1}, estimated wait: ${Math.ceil(data.estimatedWait / 1000)}s`);
            }
            if (!data.success || !data.result) {
                throw new Error(data.error || 'AI request failed - no result returned');
            }
            const text = data?.result || '[]';
            return validatePlanJson(text);
        }

        function validatePlanJson(text) {
            let plan;
            try {
                // Extract JSON if wrapped accidentally
                const firstBracket = text.indexOf('[');
                const lastBracket = text.lastIndexOf(']');
                const json = (firstBracket !== -1 && lastBracket !== -1) ? text.slice(firstBracket, lastBracket + 1) : text;
                plan = JSON.parse(json);
            } catch (e) {
                throw new Error('Invalid plan JSON');
            }
            if (!Array.isArray(plan)) throw new Error('Plan not array');
            // Basic schema check and normalization
            const normalized = [];
            for (let i = 0; i < plan.length; i++) {
                const u = plan[i] || {};
                const number = Number(u.number) || (i + 1);
                const title = (u.title || `Unit ${number}`).toString();
                const topicsIn = Array.isArray(u.topics) ? u.topics : [];
                // Enforce sequential topic numbering: unitNumber.1, unitNumber.2, ...
                const topics = topicsIn.map((t, idx) => {
                    const tn = `${number}.${idx + 1}`;
                    const tt = (t && t.title) ? String(t.title) : tn;
                    return { number: tn, title: tt };
                });
                normalized.push({ number, title, topics });
            }
            return normalized;
        }

        function renderSidebarFromPlan(plan) {
            const unitsList = document.getElementById('unitsList');
            unitsList.innerHTML = '';
            plan.forEach((unit) => {
                const unitDiv = document.createElement('div');
                unitDiv.className = 'unit';
                const unitTitle = document.createElement('div');
                unitTitle.className = 'unit-title';
                unitTitle.textContent = `Unit ${unit.number}: ${unit.title}`;
                unitTitle.addEventListener('click', () => {
                    const el = document.getElementById(`unit-${unit.number}`);
                    if (el) el.scrollIntoView({ behavior: 'smooth' });
                });
                unitDiv.appendChild(unitTitle);
                unit.topics.forEach((topic) => {
                    const topicEl = document.createElement('div');
                    topicEl.className = 'topic';
                    topicEl.textContent = `${topic.number} ${topic.title}`;
                    topicEl.addEventListener('click', () => {
                        showTopicPage(topic.number);
                    });
                    unitDiv.appendChild(topicEl);
                });
                unitsList.appendChild(unitDiv);
            });
        }

        function ensureTopicPageContainer() {
            if (!document.getElementById('notebookContent')) {
                notebook.innerHTML = `
                    <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                    <div class="gen-progress-wrap" id="genProgressWrap">
                        <div class="gen-progress-title" id="genProgressTitle">Preparing generation...</div>
                        <div class="gen-progress"><div class="gen-progress-fill" id="genProgressFill"></div></div>
                    </div>
                    <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                `;
            }
            const container = document.getElementById('notebookContent');
            if (!document.getElementById('topicPageContainer')) {
                const pages = document.createElement('div');
                pages.id = 'topicPageContainer';
                container.appendChild(pages);
            }
            return document.getElementById('topicPageContainer');
        }

        function showTopicPage(topicNumber) {
            const id = `page-topic-${topicNumber.replace('.', '-')}`;
            const pages = document.querySelectorAll('.topic-page');
            
            // Check if we're currently viewing quiz and switching to regular notes
            const currentlyViewingQuiz = document.getElementById('page-quiz')?.classList.contains('active');
            
            pages.forEach(p => p.classList.remove('active'));
            const target = document.getElementById(id);
            if (target) target.classList.add('active');
            
            // If switching from quiz to notes, no action needed
            // If switching from notes to quiz, that's handled by the quiz generator
        }

        function appendUnitContentShell(unit) {
            // Ensure notebook container and page container exist, but do not render unit title text
            if (!document.getElementById('notebookContent')) {
                notebook.innerHTML = `
                    <h2>ðŸ“š ${currentCourse.name} - Study Notes</h2>
                    <div id="notebookContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                `;
            }
            ensureTopicPageContainer();
        }

        async function generateTopicNotes(course, classType, extractedText, unitPlan, topic, usedFiles = []) {
            const formatPrompt = getFormatPrompt(classType, course.name);
            
            // Create file reference section if files are provided
            let fileReferenceSection = '';
            if (usedFiles && usedFiles.length > 0) {
                const fileNames = usedFiles.map(f => f.name || f).filter(Boolean);
                if (fileNames.length > 0) {
                    fileReferenceSection = `\n\nSOURCE FILES (for reference):\n${fileNames.map(name => `- ${name}`).join('\n')}\n\nPlease include brief file references in your notes where relevant (e.g., "Based on [filename.pdf]" or "See [filename.pptx] for more details").`;
                }
            }
            
            const prompt = `Create study notes ONLY for this topic using the EXACT format sections.\n\nCOURSE: ${course.name}\nCLASS TYPE: ${classType}\nUNIT: ${unitPlan.number} ${unitPlan.title}\nTOPIC: ${topic.number} (${topic.title})\n\nEXTRACTED COURSE CONTENT (may be truncated):\n${capExtractedText(extractedText)}${fileReferenceSection}\n\n${formatPrompt}\n\nIMPORTANT:\n- Only write notes for this single topic.\n- Do not include other units or topics.\n- Use {VOCAB}word{VOCAB} markers around vocabulary terms and important definitions.\n- Use {PRACTICE}example{PRACTICE} markers around practice problems, examples, and steps.\n- Include file references where relevant to help users know which source materials were used for this topic.`;
            return await retryWithBackoff(async () => {
                const workerApiBase = 'https://sparkling-lake-6be2.quintify2.workers.dev';
                const aiResponse = await fetch(`${workerApiBase}/api/ai-request`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: prompt })
                });
                if (!aiResponse.ok) {
                    const errorText = await aiResponse.text();
                    throw new Error(`AI Topic Generation Error: ${aiResponse.status} - ${errorText}`);
                }
                const aiData = await aiResponse.json();
                if (aiData.queued) {
                    throw new Error(`Queue position: ${aiData.position + 1}, estimated wait: ${Math.ceil(aiData.estimatedWait / 1000)}s`);
                }
                return aiData?.result || '';
            });
        }

        function injectTopicPage(unitPlan, topic, topicText, preserveExisting = true) {
            const pages = ensureTopicPageContainer();
            const id = `page-topic-${topic.number.replace('.', '-')}`;
            if (preserveExisting && document.getElementById(id)) return; // already exists - preserve it
            const page = document.createElement('div');
            page.className = 'topic-page';
            page.id = id;
            // Ensure canonical topic header present at top
            let body = topicText || '';
            const headerPattern = new RegExp(`^\s*${escapeRegex(topic.number)}(\s|:|\-|\\()`, 'm');
            if (!headerPattern.test(body)) {
                body = `${topic.number} (${topic.title})\n` + body;
            }
            
            // Apply colors to the content
            body = applyVocabColors(body, getColorValue(settings.vocabColor));
            body = applyPracticeColors(body, getColorValue(settings.practiceColor));
            
            // Wrap in content div for styling
            page.innerHTML = `<div class="topic-page-content">${body}</div>`;
            pages.appendChild(page);
        }
        
        function getColorValue(colorValue) {
            // Handle both hex values and legacy color names
            if (colorValue.startsWith('#')) {
                return colorValue;
            }
            const colorMap = {
                red: '#8b0000',
                blue: '#00008b',
                green: '#006400',
                purple: '#4b0082',
                pink: '#8b0063',
                orange: '#cc5500',
                yellow: '#8b8b00',
                black: '#000000'
            };
            return colorMap[colorValue] || colorMap.blue;
        }

        function saveCurrentCourseNotes() {
            if (!currentCourse) {
                alert('No course selected.');
                return;
            }
            
            // Get current notes data (check both string and number key for compatibility)
            const courseIdStr = String(currentCourse.id);
            let notes = savedNotes[courseIdStr] || savedNotes[currentCourse.id];
            if (!notes || !notes.content || notes.content.length === 0) {
                alert('No notes to save. Please generate notes first.');
                return;
            }
            
            // Capture current topic pages' HTML content
            const topicPagesContent = {};
            if (notes.units && Array.isArray(notes.units)) {
                notes.units.forEach(unit => {
                    if (unit.topics && Array.isArray(unit.topics)) {
                        unit.topics.forEach(topic => {
                            const pageId = `page-topic-${topic.number.replace('.', '-')}`;
                            const pageElement = document.getElementById(pageId);
                            if (pageElement) {
                                topicPagesContent[topic.number] = pageElement.innerHTML;
                            }
                        });
                    }
                });
            }
            
            // Update notes with current topic pages content
            notes = {
                ...notes,
                topicPages: topicPagesContent
            };
            
            // Save immediately
            const saveSuccess = safeSaveNotes(courseIdStr, notes);
            if (saveSuccess) {
                // Update in-memory copy to ensure consistency
                savedNotes[courseIdStr] = notes;
                // Visual feedback
                saveNotesBtn.textContent = 'âœ… Saved!';
                saveNotesBtn.style.background = '#4caf50';
                setTimeout(() => {
                    saveNotesBtn.textContent = 'ðŸ’¾ Save Notes';
                    saveNotesBtn.style.background = '';
                }, 2000);
            } else {
                alert('Failed to save notes. Check browser console for details.');
            }
        }

        function clearCurrentCourseNotes() {
            if (!currentCourse) return;
            if (!confirm('Clear all saved notes for this class?')) return;
            const cleaned = safeLoadNotes();
            delete cleaned[String(currentCourse.id)];
            try {
                localStorage.setItem('canvasNotes', JSON.stringify(cleaned));
                savedNotes = cleaned;
            } catch (e) {
                console.error('Error clearing notes:', e);
            }
            // Reset UI to upload state
            const unitsList = document.getElementById('unitsList');
            if (unitsList) unitsList.innerHTML = '';
            notebook.innerHTML = '';
            showFileUpload(currentCourse);
            renderCourses();
        }

        // Robust localStorage save with error handling
        function safeSaveNotes(courseId, notesData) {
            try {
                // Convert courseId to string if it's a number
                const courseIdStr = String(courseId || '');
                if (!courseIdStr || courseIdStr === 'undefined' || courseIdStr === 'null') {
                    console.error('Invalid courseId for save:', courseId);
                    return false;
                }
                // Validate structure
                if (!notesData || typeof notesData !== 'object') {
                    console.error('Invalid notesData structure');
                    return false;
                }
                // Ensure required fields with proper defaults
                if (!Array.isArray(notesData.units)) {
                    notesData.units = [];
                }
                if (typeof notesData.content !== 'string') {
                    notesData.content = String(notesData.content || '');
                }
                if (!Array.isArray(notesData.usedFiles)) {
                    notesData.usedFiles = [];
                }
                
                // Load existing, merge safely
                const existing = safeLoadNotes();
                const courseData = {
                    content: String(notesData.content || ''),
                    units: Array.isArray(notesData.units) ? notesData.units.map(u => ({
                        number: Number(u.number) || 1,
                        title: String(u.title || ''),
                        topics: Array.isArray(u.topics) ? u.topics.map(t => ({
                            number: String(t.number || ''),
                            title: String(t.title || '')
                        })) : []
                    })) : [],
                    usedFiles: Array.isArray(notesData.usedFiles) ? notesData.usedFiles : [],
                    topicPages: notesData.topicPages && typeof notesData.topicPages === 'object' ? notesData.topicPages : {}, // Preserve topic pages HTML
                    generatedAt: String(notesData.generatedAt || new Date().toISOString())
                };
                
                existing[courseIdStr] = courseData;
                
                // Save to localStorage with error handling
                try {
                    localStorage.setItem('canvasNotes', JSON.stringify(existing));
                    // Verify it was saved
                    const verify = localStorage.getItem('canvasNotes');
                    if (!verify) {
                        console.error('Failed to verify save - localStorage returned null');
                        return false;
                    }
                    savedNotes = existing;
                    console.log('Notes saved successfully for course:', courseId, 'Content length:', courseData.content.length);
                    return true;
                } catch (storageError) {
                    console.error('localStorage.setItem error:', storageError);
                    // Check if quota exceeded
                    if (storageError.name === 'QuotaExceededError') {
                        console.error('localStorage quota exceeded - cannot save notes');
                    }
                    return false;
                }
            } catch (error) {
                console.error('Error saving notes:', error);
                return false;
            }
        }
        
        // Robust localStorage load with error handling
        function safeLoadNotes() {
            try {
                const data = localStorage.getItem('canvasNotes');
                if (!data) {
                    console.log('No saved notes found in localStorage');
                    return {};
                }
                const parsed = JSON.parse(data);
                if (typeof parsed !== 'object' || parsed === null) {
                    console.warn('Invalid notes data structure, returning empty');
                    return {};
                }
                // Validate each course entry but preserve all data (including topicPages)
                const cleaned = {};
                let count = 0;
                for (const [key, value] of Object.entries(parsed)) {
                    if (typeof value === 'object' && value !== null) {
                        // Preserve content, topicPages, and all other fields exactly as saved - don't truncate or modify
                        cleaned[key] = {
                            content: String(value.content || ''),
                            units: Array.isArray(value.units) ? value.units.filter(u => u && typeof u === 'object').map(u => ({
                                number: Number(u.number) || 1,
                                title: String(u.title || ''),
                                topics: Array.isArray(u.topics) ? u.topics.filter(t => t && typeof t === 'object').map(t => ({
                                    number: String(t.number || ''),
                                    title: String(t.title || '')
                                })) : []
                            })) : [],
                            usedFiles: Array.isArray(value.usedFiles) ? value.usedFiles : [],
                            topicPages: value.topicPages && typeof value.topicPages === 'object' ? value.topicPages : {}, // Preserve topic pages HTML
                            generatedAt: String(value.generatedAt || new Date().toISOString())
                        };
                        count++;
                    }
                }
                console.log(`Loaded ${count} course(s) from localStorage`);
                return cleaned;
            } catch (error) {
                console.error('Error loading notes:', error);
                // Don't delete on parse error - might be recoverable
                // Only delete if it's completely invalid
                try {
                    const test = localStorage.getItem('canvasNotes');
                    if (test && test.length > 0) {
                        console.warn('Notes exist but failed to parse - keeping raw data');
                        return {};
                    }
                } catch (_) {}
                return {};
            }
        }


        // Initialize the app
        init();
        
        // Start ban status polling if user is already logged in
        if (canvasToken) {
            // Start polling immediately if token exists (user is logged in)
            startBanStatusPolling();
        }
        
        // Clean up polling when page unloads
        window.addEventListener('beforeunload', () => {
            stopBanStatusPolling();
        });
        
        // Also pause/resume polling based on page visibility (optional optimization)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, but we'll keep polling to detect bans quickly
                // If you want to pause polling when hidden, uncomment:
                // stopBanStatusPolling();
            } else {
                // Page is visible again, ensure polling is active if user is logged in
                if (canvasToken && !banCheckInterval) {
                    startBanStatusPolling();
                }
            }
        });

        // Defensive fallbacks in case helpers are not yet defined
        if (typeof showUnitTopicProgress !== 'function') {
            function showUnitTopicProgress(unitPlan) { /* no-op */ }
        }
        if (typeof updateUnitTopicProgress !== 'function') {
            function updateUnitTopicProgress(unitNumber, completed, total) { /* no-op */ }
        }
        if (typeof finishUnitTopicProgress !== 'function') {
            function finishUnitTopicProgress(unitNumber) { /* no-op */ }
        }

        // Utility: escape regex special characters in a string
        function escapeRegex(s) {
            return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
    </script>
</body>
</html>
