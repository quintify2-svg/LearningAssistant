// Service Worker for Data Management
// Handles tracking, management, and content generation

// KV namespace: USER_DATA
// Environment: SECRET_KEY

export default {
    async fetch(request, env) {
        const url = new URL(request.url);
        const path = url.pathname;
        
        // CORS headers
        const corsHeaders = {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        };
        
        // Handle preflight
        if (request.method === 'OPTIONS') {
            return new Response(null, { headers: corsHeaders });
        }
        
        try {
            // Check if KV namespace is bound
            if (!env.USER_DATA) {
                return new Response(JSON.stringify({ error: 'KV namespace USER_DATA not bound. Please bind it in worker settings.' }), {
                    status: 500,
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Heartbeat (send signal every 5 seconds to indicate user is online)
            if (path === '/api/heartbeat' && request.method === 'POST') {
                const data = await request.json();
                
                // Try to find existing user by first and last name
                let userId = null;
                const userName = data.canvasData?.name || 'Unknown User';
                const { firstName, lastName } = parseName(userName);
                const existingUserId = await findUserByName(env, firstName, lastName);
                
                if (existingUserId) {
                    userId = existingUserId;
                } else {
                    // Fallback to generating ID
                    userId = generateUserId(data.token, data.device);
                }
                
                // Get user data
                const userData = await env.USER_DATA.get(userId, 'json');
                
                if (userData) {
                    // Update heartbeat timestamp
                    userData.lastHeartbeat = new Date().toISOString();
                    userData.lastActive = new Date().toISOString(); // Also update lastActive
                    await env.USER_DATA.put(userId, JSON.stringify(userData));
                }
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Check ban status (used by learning assistant)
            if (path === '/api/check-ban' && request.method === 'POST') {
                const data = await request.json();
                
                // Try to find existing user by first and last name
                let userId = null;
                const userName = data.canvasData?.name || 'Unknown User';
                const { firstName, lastName } = parseName(userName);
                const existingUserId = await findUserByName(env, firstName, lastName);
                
                if (existingUserId) {
                    userId = existingUserId;
                } else {
                    // Fallback to generating ID
                    userId = generateUserId(data.token, data.device);
                }
                
                // Check ban by name first (so bans persist even if user changes API token)
                const nameKey = `NAME_LOOKUP:${firstName.toLowerCase()}:${lastName.toLowerCase()}`;
                const nameBannedUserId = await env.USER_DATA.get(nameKey);
                
                // Also check name-based ban record
                const nameBanKey = `NAME_BAN:${firstName.toLowerCase()}:${lastName.toLowerCase()}`;
                const nameBanData = await env.USER_DATA.get(nameBanKey, 'json');
                
                // Get user data (either by name lookup or generated ID)
                let userData = null;
                if (nameBannedUserId) {
                    userData = await env.USER_DATA.get(nameBannedUserId, 'json');
                }
                if (!userData && userId) {
                    userData = await env.USER_DATA.get(userId, 'json');
                }
                
                // Check if ban has expired (check both userData ban and name-based ban)
                let isBanned = userData?.banned || false;
                let banReason = userData?.banReason || null;
                let banDuration = null;
                
                // Also check name-based ban (priority - this prevents API token changes from bypassing ban)
                if (nameBanData && nameBanData.banned) {
                    isBanned = true;
                    banReason = nameBanData.banReason || banReason;
                    
                    // Check if name-based ban has expired
                    if (nameBanData.unbanAt) {
                        const unbanAt = new Date(nameBanData.unbanAt);
                        if (unbanAt <= new Date()) {
                            // Name ban expired, remove it
                            await env.USER_DATA.delete(nameBanKey);
                            isBanned = false;
                            banReason = null;
                        } else {
                            // Calculate remaining duration in hours
                            const remainingMs = unbanAt.getTime() - Date.now();
                            banDuration = Math.ceil(remainingMs / (1000 * 60 * 60));
                        }
                    }
                } else if (isBanned && userData?.unbanAt) {
                    const unbanAt = new Date(userData.unbanAt);
                    if (unbanAt <= new Date()) {
                        // Ban expired, unban user
                        userData.banned = false;
                        userData.banReason = null;
                        userData.bannedAt = null;
                        userData.unbanAt = null;
                        if (userData.id) {
                            await env.USER_DATA.put(userData.id, JSON.stringify(userData));
                        }
                        isBanned = false;
                        banReason = null;
                    } else {
                        // Calculate remaining duration in hours
                        const remainingMs = unbanAt.getTime() - Date.now();
                        banDuration = Math.ceil(remainingMs / (1000 * 60 * 60));
                    }
                }
                
                // Check for active announcement
                const announcement = await env.USER_DATA.get('CURRENT_ANNOUNCEMENT', 'json');
                
                return new Response(JSON.stringify({
                    banned: isBanned,
                    reason: banReason,
                    duration: banDuration, // hours remaining, null if permanent
                    warning: userData?.lastWarning || null,
                    announcement: announcement || null
                }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Register/track user (called by learning assistant)
            if (path === '/api/track-user' && request.method === 'POST') {
                const data = await request.json();
                
                // Get user name and parse first/last name
                const userName = data.canvasData?.name || 'Unknown User';
                const { firstName, lastName } = parseName(userName);
                const userIp = request.headers.get('CF-Connecting-IP') || data.device?.ip || 'Unknown';
                
                // Try to find existing user by first and last name (same person)
                let userId = null;
                const existingUserId = await findUserByName(env, firstName, lastName);
                
                if (existingUserId) {
                    // User exists (same first and last name), use their ID
                    userId = existingUserId;
                    console.log(`Found existing user: ${userId} for ${firstName} ${lastName}@${userIp}`);
                } else {
                    // New user, generate ID
                    userId = generateUserId(data.token, data.device);
                    console.log(`Created new user: ${userId} for ${firstName} ${lastName}@${userIp}`);
                    
                    // Store name lookup for future matching
                    await storeNameLookup(env, firstName, lastName, userId);
                }
                
                // Get existing user data
                let userData = await env.USER_DATA.get(userId, 'json') || {
                    id: userId,
                    createdAt: new Date().toISOString(),
                    banned: false,
                    ips: [],
                    stats: {
                        logins: 0,
                        coursesAccessed: 0,
                        notesGenerated: 0
                    }
                };
                
                // Initialize ips array if it doesn't exist (for legacy users)
                if (!userData.ips || !Array.isArray(userData.ips)) {
                    userData.ips = [];
                    // If device has an IP, add it to the array
                    if (userData.device?.ip && userData.device.ip !== 'Unknown') {
                        userData.ips.push(userData.device.ip);
                    }
                }
                
                // Add IP to list if unique
                addUniqueIP(userData, userIp);
                
                // Update user data
                userData.lastActive = new Date().toISOString();
                userData.stats.logins = (userData.stats.logins || 0) + 1;
                
                // Store Canvas API data
                if (data.canvasData) {
                    userData.canvasData = data.canvasData;
                    userData.name = data.canvasData.name;
                    userData.email = data.canvasData.email || data.canvasData.primary_email;
                    // Store first and last name for reference
                    userData.firstName = firstName;
                    userData.lastName = lastName;
                }
                
                // Store Canvas API token (for tracking)
                if (data.token) {
                    userData.canvasApiToken = data.token; // Store token hash or masked version
                }
                
                // Store calendar feed URL if provided
                if (data.calendarFeedUrl) {
                    userData.calendarFeedUrl = data.calendarFeedUrl;
                }
                
                // Store courses if provided from learning assistant
                if (data.courses && Array.isArray(data.courses)) {
                    userData.courses = data.courses;
                    userData.coursesUpdatedAt = new Date().toISOString();
                }
                
                // Store device info
                if (data.device) {
                    userData.device = {
                        ...data.device,
                        ip: userIp // Keep single IP in device for compatibility
                    };
                }
                
                // Save to KV
                await env.USER_DATA.put(userId, JSON.stringify(userData));
                
                // Add to users list
                let usersList = await env.USER_DATA.get('USERS_LIST', 'json') || [];
                if (!usersList.includes(userId)) {
                    usersList.push(userId);
                    await env.USER_DATA.put('USERS_LIST', JSON.stringify(usersList));
                }
                
                return new Response(JSON.stringify({ success: true, userId }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Track course access
            if (path === '/api/track-course' && request.method === 'POST') {
                const data = await request.json();
                
                // Try to find existing user by first and last name
                let userId = null;
                const userName = data.canvasData?.name || 'Unknown User';
                const { firstName, lastName } = parseName(userName);
                const userIp = request.headers.get('CF-Connecting-IP') || data.device?.ip || 'Unknown';
                const existingUserId = await findUserByName(env, firstName, lastName);
                
                if (existingUserId) {
                    userId = existingUserId;
                } else {
                    userId = generateUserId(data.token, data.device);
                    await storeNameLookup(env, firstName, lastName, userId);
                }
                
                const userData = await env.USER_DATA.get(userId, 'json') || {
                    id: userId,
                    createdAt: new Date().toISOString(),
                    banned: false,
                    ips: [],
                    stats: {
                        logins: 0,
                        coursesAccessed: 0,
                        notesGenerated: 0
                    }
                };
                
                // Initialize ips array if it doesn't exist (for legacy users)
                if (!userData.ips || !Array.isArray(userData.ips)) {
                    userData.ips = [];
                    // If device has an IP, add it to the array
                    if (userData.device?.ip && userData.device.ip !== 'Unknown') {
                        userData.ips.push(userData.device.ip);
                    }
                }
                
                // Add IP to list if unique
                addUniqueIP(userData, userIp);
                
                userData.lastActive = new Date().toISOString();
                userData.stats.coursesAccessed = (userData.stats.coursesAccessed || 0) + 1;
                
                // Store Canvas API data if provided
                if (data.canvasData) {
                    userData.canvasData = data.canvasData;
                    userData.name = userData.name || data.canvasData.name;
                    userData.email = userData.email || data.canvasData.email || data.canvasData.primary_email;
                    userData.firstName = userData.firstName || firstName;
                    userData.lastName = userData.lastName || lastName;
                }
                
                // Store courses if provided from learning assistant
                if (data.courses && Array.isArray(data.courses)) {
                    userData.courses = data.courses;
                    userData.coursesUpdatedAt = new Date().toISOString();
                }
                
                if (data.device) {
                    userData.device = {
                        ...data.device,
                        ip: userIp
                    };
                }
                
                // Save to KV
                await env.USER_DATA.put(userId, JSON.stringify(userData));
                
                // Add to users list
                let usersList = await env.USER_DATA.get('USERS_LIST', 'json') || [];
                if (!usersList.includes(userId)) {
                    usersList.push(userId);
                    await env.USER_DATA.put('USERS_LIST', JSON.stringify(usersList));
                }
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Track notes generation
            if (path === '/api/track-notes' && request.method === 'POST') {
                const data = await request.json();
                
                // Try to find existing user by first and last name
                let userId = null;
                const userName = data.canvasData?.name || 'Unknown User';
                const { firstName, lastName } = parseName(userName);
                const userIp = request.headers.get('CF-Connecting-IP') || data.device?.ip || 'Unknown';
                const existingUserId = await findUserByName(env, firstName, lastName);
                
                if (existingUserId) {
                    userId = existingUserId;
                } else {
                    // Fallback to generating ID
                    userId = generateUserId(data.token, data.device);
                    await storeNameLookup(env, firstName, lastName, userId);
                }
                
                const userData = await env.USER_DATA.get(userId, 'json');
                
                if (userData) {
                    // Initialize ips array if it doesn't exist (for legacy users)
                    if (!userData.ips || !Array.isArray(userData.ips)) {
                        userData.ips = [];
                        // If device has an IP, add it to the array
                        if (userData.device?.ip && userData.device.ip !== 'Unknown') {
                            userData.ips.push(userData.device.ip);
                        }
                    }
                    
                    // Add IP to list if unique
                    addUniqueIP(userData, userIp);
                    userData.stats.notesGenerated = (userData.stats.notesGenerated || 0) + 1;
                    userData.lastActive = new Date().toISOString();
                    await env.USER_DATA.put(userId, JSON.stringify(userData));
                }
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Helper function for admin authentication
            function checkAdminAuth() {
                if (!env.SECRET_KEY) {
                    return new Response(JSON.stringify({ error: 'Configuration error: SECRET_KEY not set in worker environment. Please set SECRET_KEY environment variable in your Cloudflare Worker settings.' }), {
                        status: 500,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                const authHeader = request.headers.get('Authorization');
                if (authHeader !== `Bearer ${env.SECRET_KEY}`) {
                    return new Response(JSON.stringify({ error: 'Unauthorized' }), {
                        status: 401,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                return null; // Auth passed
            }
            
            // AI Generation Queue and Rate Limiting (obfuscated endpoint name)
            if (path === '/api/generate' && request.method === 'POST') {
                try {
                const data = await request.json();
                
                    if (!data || !data.prompt) {
                        return new Response(JSON.stringify({ 
                            error: 'Missing prompt in request body',
                            success: false
                        }), {
                            status: 400,
                            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                        });
                    }
                
                // Check rate limit first
                const rateLimitData = await env.USER_DATA.get('RL_DATA', 'json') || {
                    count: 0,
                    resetAt: Date.now() + 70000,
                    lastRequest: Date.now()
                };
                
                // If we've hit 10 requests, wait 70 seconds (1 min 10 sec)
                if (rateLimitData.count >= 10) {
                    const waitTime = Math.max(0, rateLimitData.resetAt - Date.now());
                    if (waitTime > 0) {
                        // Get queue and clean up old items (older than 5 minutes)
                        const queueData = await env.USER_DATA.get('REQ_QUEUE', 'json') || [];
                        const now = Date.now();
                        const cleanedQueue = queueData.filter(item => (now - item.timestamp) < 300000); // 5 minutes
                        const position = cleanedQueue.length;
                        
                        // Add to queue
                        const requestId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
                        cleanedQueue.push({
                            id: requestId,
                            timestamp: Date.now(),
                            userId: data.userId || 'unknown'
                        });
                        await env.USER_DATA.put('REQ_QUEUE', JSON.stringify(cleanedQueue));
                        
                        return new Response(JSON.stringify({
                            queued: true,
                            position: position,
                            waitTime: waitTime,
                            estimatedWait: waitTime + (position * 2000) // Estimate 2s per request
                        }), {
                            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                        });
                    } else {
                        // Reset period passed, reset counter
                        rateLimitData.count = 0;
                        rateLimitData.resetAt = Date.now() + 70000;
                        // Clean up queue when reset happens
                        const queueData = await env.USER_DATA.get('REQ_QUEUE', 'json') || [];
                        const now = Date.now();
                        const cleanedQueue = queueData.filter(item => (now - item.timestamp) < 300000);
                        if (cleanedQueue.length !== queueData.length) {
                            await env.USER_DATA.put('REQ_QUEUE', JSON.stringify(cleanedQueue));
                        }
                    }
                }
                
                // Process request immediately
                rateLimitData.count++;
                rateLimitData.lastRequest = Date.now();
                if (rateLimitData.count === 10) {
                    rateLimitData.resetAt = Date.now() + 70000; // 70 seconds (1 min 10 sec)
                }
                await env.USER_DATA.put('RL_DATA', JSON.stringify(rateLimitData));
                
                // Make AI request (wait for response)
                const aiKey = 'AIzaSyAaDVm2iSoLZjQrQTR-JP7jjREVsD3IiTo';
                try {
                    const aiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${aiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: data.prompt }] }]
                        })
                    });
                    
                    if (!aiResponse.ok) {
                        const errorText = await aiResponse.text();
                        console.error('AI API error:', aiResponse.status, errorText);
                        
                        // Handle specific error cases
                        let errorMessage = `AI API error: ${aiResponse.status}`;
                        let errorDetails = errorText;
                        
                        if (aiResponse.status === 503) {
                            // Model overloaded - return a user-friendly message
                            try {
                                const errorJson = JSON.parse(errorText);
                                if (errorJson.error?.message) {
                                    errorMessage = 'AI service is temporarily overloaded. Please try again in a few moments.';
                                    errorDetails = errorJson.error.message;
                                }
                            } catch (e) {
                                errorMessage = 'AI service is temporarily overloaded. Please try again in a few moments.';
                            }
                        } else if (aiResponse.status === 429) {
                            errorMessage = 'AI service rate limit exceeded. Please wait a moment and try again.';
                        }
                        
                        const error = new Error(errorMessage);
                        error.status = aiResponse.status;
                        error.details = errorDetails;
                        throw error;
                    }
                    
                    const aiData = await aiResponse.json();
                    if (!aiData.candidates || !aiData.candidates[0] || !aiData.candidates[0].content) {
                        throw new Error('Invalid AI response format');
                    }
                    
                    return new Response(JSON.stringify({
                        success: true,
                        result: aiData.candidates[0].content.parts[0].text
                    }), {
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                } catch (aiError) {
                    console.error('Error making AI request:', aiError);
                    // Decrement counter on error so request slot isn't wasted
                    rateLimitData.count = Math.max(0, rateLimitData.count - 1);
                    await env.USER_DATA.put('RL_DATA', JSON.stringify(rateLimitData));
                    
                    return new Response(JSON.stringify({ 
                        error: aiError.message || 'AI request failed',
                        success: false,
                        details: aiError.toString()
                    }), {
                        status: 500,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                } catch (parseError) {
                    console.error('Error parsing request:', parseError);
                    return new Response(JSON.stringify({ 
                        error: 'Invalid request format',
                        success: false,
                        details: parseError.message
                    }), {
                        status: 400,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
            }
            
            // Alias for compatibility (route to same handler)
            if (path === '/api/ai-request' && request.method === 'POST') {
                try {
                    // Reuse the same logic as /api/generate
                    const data = await request.json();
                    
                    if (!data || !data.prompt) {
                        return new Response(JSON.stringify({ 
                            error: 'Missing prompt in request body',
                            success: false
                        }), {
                            status: 400,
                            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                        });
                    }
                
                const rateLimitData = await env.USER_DATA.get('RL_DATA', 'json') || {
                    count: 0,
                    resetAt: Date.now() + 70000,
                    lastRequest: Date.now()
                };
                
                if (rateLimitData.count >= 10) {
                    const waitTime = Math.max(0, rateLimitData.resetAt - Date.now());
                    if (waitTime > 0) {
                        // Get queue and clean up old items
                        const queueData = await env.USER_DATA.get('REQ_QUEUE', 'json') || [];
                        const now = Date.now();
                        const cleanedQueue = queueData.filter(item => (now - item.timestamp) < 300000);
                        const position = cleanedQueue.length;
                        const requestId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
                        cleanedQueue.push({
                            id: requestId,
                            timestamp: Date.now(),
                            userId: data.userId || 'unknown'
                        });
                        await env.USER_DATA.put('REQ_QUEUE', JSON.stringify(cleanedQueue));
                        
                        return new Response(JSON.stringify({
                            queued: true,
                            position: position,
                            waitTime: waitTime,
                            estimatedWait: waitTime + (position * 2000)
                        }), {
                            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                        });
                    } else {
                        // Reset period passed, reset counter and clean queue
                        rateLimitData.count = 0;
                        rateLimitData.resetAt = Date.now() + 70000;
                        const queueData = await env.USER_DATA.get('REQ_QUEUE', 'json') || [];
                        const now = Date.now();
                        const cleanedQueue = queueData.filter(item => (now - item.timestamp) < 300000);
                        if (cleanedQueue.length !== queueData.length) {
                            await env.USER_DATA.put('REQ_QUEUE', JSON.stringify(cleanedQueue));
                        }
                    }
                }
                
                rateLimitData.count++;
                rateLimitData.lastRequest = Date.now();
                if (rateLimitData.count === 10) {
                    rateLimitData.resetAt = Date.now() + 70000; // 70 seconds (1 min 10 sec)
                }
                await env.USER_DATA.put('RL_DATA', JSON.stringify(rateLimitData));
                
                const aiKey = 'AIzaSyAaDVm2iSoLZjQrQTR-JP7jjREVsD3IiTo';
                try {
                const aiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${aiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: data.prompt }] }]
                    })
                });
                
                if (!aiResponse.ok) {
                        const errorText = await aiResponse.text();
                        console.error('AI API error:', aiResponse.status, errorText);
                        throw new Error(`AI API error: ${aiResponse.status} - ${errorText}`);
                    }
                    
                    const aiData = await aiResponse.json();
                    if (!aiData.candidates || !aiData.candidates[0] || !aiData.candidates[0].content) {
                        throw new Error('Invalid AI response format');
                    }
                    
                    return new Response(JSON.stringify({
                        success: true,
                        result: aiData.candidates[0].content.parts[0].text
                    }), {
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                } catch (aiError) {
                    console.error('Error making AI request:', aiError);
                    // Decrement counter on error so request slot isn't wasted
                    rateLimitData.count = Math.max(0, rateLimitData.count - 1);
                    await env.USER_DATA.put('RL_DATA', JSON.stringify(rateLimitData));
                    
                    return new Response(JSON.stringify({ 
                        error: aiError.message || 'AI request failed',
                        success: false,
                        details: aiError.toString()
                    }), {
                        status: 500,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                } catch (parseError) {
                    console.error('Error parsing request:', parseError);
                    return new Response(JSON.stringify({ 
                        error: 'Invalid request format',
                        success: false,
                        details: parseError.message
                    }), {
                        status: 400,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
            }
            
            // Check queue position (obfuscated endpoint)
            if (path === '/api/status' && request.method === 'GET') {
                const queueData = await env.USER_DATA.get('REQ_QUEUE', 'json') || [];
                // Clean up old queue items
                const now = Date.now();
                const cleanedQueue = queueData.filter(item => (now - item.timestamp) < 300000);
                if (cleanedQueue.length !== queueData.length) {
                    await env.USER_DATA.put('REQ_QUEUE', JSON.stringify(cleanedQueue));
                }
                
                const rateLimitData = await env.USER_DATA.get('RL_DATA', 'json') || {
                    count: 0,
                    resetAt: Date.now() + 70000
                };
                
                const waitTime = rateLimitData.count >= 10 ? Math.max(0, rateLimitData.resetAt - Date.now()) : 0;
                
                return new Response(JSON.stringify({
                    queueLength: cleanedQueue.length,
                    rateLimitCount: rateLimitData.count,
                    waitTime: waitTime,
                    estimatedWait: waitTime + (cleanedQueue.length * 2000)
                }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Alias for compatibility
            if (path === '/api/check-queue' && request.method === 'GET') {
                const queueData = await env.USER_DATA.get('REQ_QUEUE', 'json') || [];
                // Clean up old queue items
                const now = Date.now();
                const cleanedQueue = queueData.filter(item => (now - item.timestamp) < 300000);
                if (cleanedQueue.length !== queueData.length) {
                    await env.USER_DATA.put('REQ_QUEUE', JSON.stringify(cleanedQueue));
                }
                
                const rateLimitData = await env.USER_DATA.get('RL_DATA', 'json') || {
                    count: 0,
                    resetAt: Date.now() + 70000
                };
                
                const waitTime = rateLimitData.count >= 10 ? Math.max(0, rateLimitData.resetAt - Date.now()) : 0;
                
                return new Response(JSON.stringify({
                    queueLength: cleanedQueue.length,
                    rateLimitCount: rateLimitData.count,
                    waitTime: waitTime,
                    estimatedWait: waitTime + (cleanedQueue.length * 2000)
                }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Get all users
            if ((path === '/sys/users' || path === '/mgmt/users') && request.method === 'GET') {
                const authError = checkAdminAuth();
                if (authError) return authError;
                
                try {
                    const usersListResult = await env.USER_DATA.get('USERS_LIST', 'json');
                    const usersList = usersListResult || [];
                    const users = [];
                    
                    for (const userId of usersList) {
                        try {
                            const userData = await env.USER_DATA.get(userId, 'json');
                            if (userData) {
                                users.push(userData);
                            }
                        } catch (err) {
                            console.error(`Error loading user ${userId}:`, err);
                            // Continue with other users
                        }
                    }
                    
                    // Sort by last active (most recent first)
                    users.sort((a, b) => {
                        const timeA = new Date(a.lastActive || a.createdAt || 0).getTime();
                        const timeB = new Date(b.lastActive || b.createdAt || 0).getTime();
                        return timeB - timeA;
                    });
                    
                    return new Response(JSON.stringify(users), {
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                } catch (err) {
                    return new Response(JSON.stringify({ error: 'Error fetching users: ' + err.message }), {
                        status: 500,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
            }
            
            // Route: Get single user
            if ((path.startsWith('/sys/users/') || path.startsWith('/mgmt/users/')) && request.method === 'GET' && !path.endsWith('/ban') && !path.endsWith('/unban')) {
                const authError = checkAdminAuth();
                if (authError) return authError;
                
                const userId = path.split('/sys/users/')[1] || path.split('/mgmt/users/')[1];
                const userData = await env.USER_DATA.get(userId, 'json');
                
                if (!userData) {
                    return new Response(JSON.stringify({ error: 'User not found' }), {
                        status: 404,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                
                return new Response(JSON.stringify(userData), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Ban user
            if (path.endsWith('/ban') && request.method === 'POST') {
                const authError = checkAdminAuth();
                if (authError) return authError;
                
                const userId = (path.split('/sys/users/')[1] || path.split('/mgmt/users/')[1] || '').replace('/ban', '');
                const userData = await env.USER_DATA.get(userId, 'json');
                
                if (!userData) {
                    return new Response(JSON.stringify({ error: 'User not found' }), {
                        status: 404,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                
                // Parse request body safely
                let banReason = 'No reason provided';
                let banDuration = 0; // 0 = permanent
                try {
                    const body = await request.json();
                    banReason = body.reason || 'No reason provided';
                    banDuration = parseInt(body.duration) || 0;
                } catch (e) {
                    // If body parsing fails, use default reason
                    console.log('Could not parse ban request body, using default reason');
                }
                
                userData.banned = true;
                userData.banReason = banReason;
                userData.bannedAt = new Date().toISOString();
                if (banDuration > 0) {
                    // Calculate unban time
                    const unbanAt = new Date(Date.now() + (banDuration * 60 * 60 * 1000));
                    userData.unbanAt = unbanAt.toISOString();
                } else {
                    userData.unbanAt = null; // Permanent ban
                }
                await env.USER_DATA.put(userId, JSON.stringify(userData));
                
                // Also store ban by name so it persists even if user changes API token
                if (userData.firstName && userData.lastName) {
                    const nameKey = `NAME_BAN:${userData.firstName.toLowerCase()}:${userData.lastName.toLowerCase()}`;
                    await env.USER_DATA.put(nameKey, JSON.stringify({
                        banned: true,
                        banReason: banReason,
                        bannedAt: userData.bannedAt,
                        unbanAt: userData.unbanAt,
                        userId: userId
                    }));
                }
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Warn user
            if (path.endsWith('/warn') && request.method === 'POST') {
                const authError = checkAdminAuth();
                if (authError) return authError;
                
                const userId = (path.split('/sys/users/')[1] || path.split('/mgmt/users/')[1] || '').replace('/warn', '');
                const userData = await env.USER_DATA.get(userId, 'json');
                
                if (!userData) {
                    return new Response(JSON.stringify({ error: 'User not found' }), {
                        status: 404,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                
                // Parse request body safely
                let warnReason = 'Warning from admin';
                try {
                    const body = await request.json();
                    warnReason = body.reason || 'Warning from admin';
                } catch (e) {
                    console.log('Could not parse warn request body, using default reason');
                }
                
                // Increment warning count
                if (!userData.stats) userData.stats = {};
                userData.stats.warnings = (userData.stats.warnings || 0) + 1;
                
                // Store latest warning
                userData.lastWarning = {
                    reason: warnReason,
                    at: new Date().toISOString()
                };
                
                await env.USER_DATA.put(userId, JSON.stringify(userData));
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Unban user
            if (path.endsWith('/unban') && request.method === 'POST') {
                const authError = checkAdminAuth();
                if (authError) return authError;
                
                const userId = (path.split('/sys/users/')[1] || path.split('/mgmt/users/')[1] || '').replace('/unban', '');
                const userData = await env.USER_DATA.get(userId, 'json');
                
                if (!userData) {
                    return new Response(JSON.stringify({ error: 'User not found' }), {
                        status: 404,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                
                userData.banned = false;
                userData.banReason = null;
                userData.bannedAt = null;
                userData.unbanAt = null;
                await env.USER_DATA.put(userId, JSON.stringify(userData));
                
                // Remove name-based ban record
                if (userData.firstName && userData.lastName) {
                    const nameKey = `NAME_BAN:${userData.firstName.toLowerCase()}:${userData.lastName.toLowerCase()}`;
                    await env.USER_DATA.delete(nameKey);
                }
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Delete user
            if ((path.startsWith('/sys/users/') || path.startsWith('/mgmt/users/')) && request.method === 'DELETE') {
                const authError = checkAdminAuth();
                if (authError) return authError;
                
                const userId = path.split('/sys/users/')[1] || path.split('/mgmt/users/')[1];
                await env.USER_DATA.delete(userId);
                
                // Remove from users list
                let usersList = await env.USER_DATA.get('USERS_LIST', 'json') || [];
                usersList = usersList.filter(id => id !== userId);
                await env.USER_DATA.put('USERS_LIST', JSON.stringify(usersList));
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // Route: Send announcement to all users
            if ((path === '/sys/announcement' || path === '/mgmt/announcement') && request.method === 'POST') {
                const authError = checkAdminAuth();
                if (authError) return authError;
                
                let announcementText = '';
                try {
                    const body = await request.json();
                    announcementText = body.text || '';
                } catch (e) {
                    return new Response(JSON.stringify({ error: 'Invalid request body' }), {
                        status: 400,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                
                if (!announcementText.trim()) {
                    return new Response(JSON.stringify({ error: 'Announcement text is required' }), {
                        status: 400,
                        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                    });
                }
                
                // Store announcement (will be shown to all users when they check ban status)
                const announcement = {
                    text: announcementText,
                    createdAt: new Date().toISOString()
                };
                
                await env.USER_DATA.put('CURRENT_ANNOUNCEMENT', JSON.stringify(announcement));
                
                return new Response(JSON.stringify({ success: true }), {
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            return new Response(JSON.stringify({ error: 'Not found' }), {
                status: 404,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
            
        } catch (error) {
            console.error('Worker error:', error);
            return new Response(JSON.stringify({ 
                error: error.message,
                stack: error.stack,
                path: path
            }), {
                status: 500,
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
    }
};

// Parse name to extract first and last name
function parseName(name) {
    if (!name || name === 'Unknown User') return { firstName: 'Unknown', lastName: 'User' };
    
    const parts = name.trim().split(/\s+/);
    if (parts.length === 1) {
        return { firstName: parts[0], lastName: '' };
    }
    // Take first part as first name, rest as last name
    return {
        firstName: parts[0],
        lastName: parts.slice(1).join(' ')
    };
}

// Generate consistent user ID from token and device fingerprint
function generateUserId(token, device) {
    // Create a hash from token and device info
    const data = JSON.stringify({ token, device });
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
        const char = data.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
}

// Find user by first and last name (case-insensitive)
async function findUserByName(env, firstName, lastName) {
    const nameKey = `NAME_LOOKUP:${firstName.toLowerCase()}:${lastName.toLowerCase()}`;
    const userId = await env.USER_DATA.get(nameKey);
    return userId;
}

// Store name lookup mapping
async function storeNameLookup(env, firstName, lastName, userId) {
    const nameKey = `NAME_LOOKUP:${firstName.toLowerCase()}:${lastName.toLowerCase()}`;
    await env.USER_DATA.put(nameKey, userId);
}

// Add IP to user's IP list if unique
function addUniqueIP(userData, ip) {
    if (!ip || ip === 'Unknown') return;
    
    if (!userData.ips) {
        userData.ips = [];
    }
    
    // Add IP if not already in list
    if (!userData.ips.includes(ip)) {
        userData.ips.push(ip);
    }
}


